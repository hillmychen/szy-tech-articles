![9787115385734](../../../static/img/9787115385734.jpg)

# 《你不知道的JavaScript》

> 据说上卷很不错，先买上卷看，如果不错就在网上啃下卷英文版的~
 
 > 真的印证了那句话，人的记忆是离散的。两个月前看的前三章，还划线标记各种，但现在基本不记得了，就记得描述作用域时作者用高楼大厦的比喻。哎，看来还是得多记笔记。
 
## 第1章：作用域时什么

- 开篇作者用程序的本质引出了作用域的概念：
  - 编程语言中，在一个变量中存储值，并能访问和修改，这种能力使得程序带上了状态的功能。哪这些变量住在哪里、存储在哪里？程序需要的时候如何访问它们呢？
  - 这些问题说明需要一套设计良好的规则来存储变量，并且之后可以方便的访问它们。这套规则就程序***作用域***。

### 1.1 编译原理




### 1.2 理解作用域

> 总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有生命过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会给他赋值。

- 1.2.5 小测验

```javascript
function foo(a) {
  var b = a;
  return a + b;
}
var c = foo(2);
```

- ① 找到其中所有LHS查询。(这里有3处!)
  - 答案：c; a; b 三处！
  - 第一次LHS查询`var c = foo(2);`，引擎会问作用域，挨哥哥找一哈c，看以前给有声明了，声明了就别脱裤子放屁。然后就进行了LHS查询~
  - 第二次LHS查询在foo函数执行前，引擎进行预解释时进行的`a = 2`，就是给foo函数形参赋值呢时候查找a时触发了LHS查询！
  - 第三次LHS查询在foo函数体内`var b = a`时触发的！

- ② 找到其中所有RHS查询。(这里有4处!)
  -  答案：foo; a; a; b 四次！
  -  第一次RHS查询发生在执行`foo(2)`时，其实了嘛，这里为啥是RHS，归根到底就是foo这个函数名的变量存的一个堆内存地址的值，所以未归到底它就是进行RHS值查询的噻！
  -  第二次RHS查询发生在`var b = a;`时，因为要查询到a的值到底是啥！
  -  第三次RHS查询发生在`return a + b;`时的`a`！
  -  第四次RHS查询发生在`return a + b;`时的`b`！

> 我靠，我竟然有种博导随手翻开幼稚园科普手册的幻觉呢，哈哈，不能骄傲，我是来刷基础的！

### 1.3 作用域嵌套


### 1.4 异常


### 1.5 小结
  



