![9787115385734](../../../static/img/9787115385734.jpg)

# 《你不知道的JavaScript》

> 据说上卷很不错，先买上卷看，如果不错就在网上啃下卷英文版的~
 
 > 真的印证了那句话，人的记忆是离散的。两个月前看的前三章，还划线标记各种，但现在基本不记得了，就记得描述作用域时作者用高楼大厦的比喻。哎，看来还是得多记笔记。
 
## 第1章：作用域时什么

- 开篇作者用程序的本质引出了作用域的概念：
  - 编程语言中，在一个变量中存储值，并能访问和修改，这种能力使得程序带上了状态的功能。哪这些变量住在哪里、存储在哪里？程序需要的时候如何访问它们呢？
  - 这些问题说明需要一套设计良好的规则来存储变量，并且之后可以方便的访问它们。这套规则就程序***作用域***。

### 1.1 编译原理

- JavaScript虽归类"动态"或"解释执行"语言，但事实上它是一门编译语言。
- 在传统编译语言的流程中，程序中的一段源代码在执行前会经历三个步骤，统称为"编译"。
  1. 分词/词法分析(Tokenizing/Lexing)
  2. 解析/语法分析
  3. 代码生成
- JavaScript的引擎不会有太多事件来进行优化，因为与其他语言不通，JavaScript的编译过程不是发生在构建之前的。对于JS来说，大部分情况下编译发生在代码执行前的几微秒(甚至更短)的时间内。简单来说，任何JS代码片段执行前都要进行编译(通常在执行前)。

### 1.2 理解作用域

- 引擎
  - 从头到尾负责整个JavaScript程序的编译及执行过程；
- 编译器
  - 引起的好友之一，负责语法分析及代码生成等脏活累活；(我太喜欢这句话了，哈哈~)
- 作用域
  - 引起的另一位好友，负责收集维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 

> 总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有生命过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会给他赋值。

- 1.2.5 小测验

```javascript
function foo(a) {
  var b = a;
  return a + b;
}
var c = foo(2);
```

- 1. 找到其中所有LHS查询。(这里有3处!)
  - 答案：c; a; b 三处！
  - 第一次LHS查询`var c = foo(2);`，引擎会问作用域，挨哥哥找一哈c，看以前给有声明了，声明了就别脱裤子放屁。然后就进行了LHS查询~
  - 第二次LHS查询在foo函数执行前，引擎进行预解释时进行的`a = 2`，就是给foo函数形参赋值呢时候查找a时触发了LHS查询！
  - 第三次LHS查询在foo函数体内`var b = a`时触发的！

- 2. 找到其中所有RHS查询。(这里有4处!)
  -  答案：foo; a; a; b 四次！
  -  第一次RHS查询发生在执行`foo(2)`时，其实了嘛，这里为啥是RHS，归根到底就是foo这个函数名的变量存的一个堆内存地址的值，所以未归到底它就是进行RHS值查询的噻！
  -  第二次RHS查询发生在`var b = a;`时，因为要查询到a的值到底是啥！
  -  第三次RHS查询发生在`return a + b;`时的`a`！
  -  第四次RHS查询发生在`return a + b;`时的`b`！


### 1.3 作用域嵌套


### 1.4 异常


### 1.5 小结
  


