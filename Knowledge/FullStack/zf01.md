# 珠峰JS全栈培训：一、作用域深入和面向对象

### 课时1：预解释

> 基本数据类型：number、string、Boolean、null、undefined
> 引用数据类型：object（{}、[]、/^$/、Date）、function

- 当浏览器加载HTML页面的时候，首先会提供一个供全局JS代码执行的环境->全局作用域（global/window），window不仅代表当前浏览器窗口对象还代表全局作用域

- JS中定义一个函数时，首先引擎会先在内存开辟一个内存空间，然后把函数体内的代码当做**字符串**存入内存空间，最后把块内存的地址赋值给函数名。

- 预解释：在当前作用域中，JS代码执行之前，浏览器会首先默认把所有带var和function的进行提前声明或定义。

  - 理解定义和声明：
    声明（declare）：var num; -> 告诉浏览器在全局作用域中有一个num的变量了，默认值undefined
    定义（defined）：num = 12; -> 给我们声明的变量赋值
  - 对于带var和function关键字的在预解释时还是不一样的
    var -> 在预解释时只提前声明
    function -> 在预解释时提前的声明和定义都完成了
  - 预解释只发生在当前的作用域下，例如：开始只对window下的进行预解释，只有函数运行时才会对函数中的进行预解释

- JS中内存的分类
  栈内存：用来提供一个供JS代码提供的环境 -> 作用域（全局作用域、私有作用域），预解释发生在栈内存当中
  堆内存：用来存储引用数据的值 -> 对象存储的属性名和属性值，函数存储的是代码字符串

- 如何区分私有变量和全局变量？
  - 在全局作用域下声明（预解释的时候）的变量是全局变量
  - 在“私有作用域中声明的变量”和“函数的形参”都是私有变量
  - 在私有作用域中，我们的代码执行时遇到了一个变量，首先我们需要确定它是否为私有变量，如果是，则和外面作用域的变量没有任何关系；如果不是私有的，则往当前作用域的上级作用域进行查找，如果上级作用域也没有则继续往上查看，一直找到windows全局位置（作用域链）。
  
----------

## 课时2：作用域链

- 当函数执行的时候（直接目的：让函数体中的代码执行），首先会形成一个新的私有的作用域，然后按如下步骤执行：
  - 如果有形参，先给形参赋值
  - 进行私有作用域的预解释
  - 私有作用域中的代码从上到下执行
  - 函数形参的一个新的私有变量保护了里面的私有变量不受外界的干扰（外面修改不了私有的，私有的也修改不了外面的）--> “闭包”

----------

### 课时3：全局变量的细节问题
  
- 私有作用域中出现的一个变量不是私有的，则往上级作用域进行查找，上级作用域没有则继续往上级查找，一直找到window为止，如果window下也没有则：
  - 若是获取值：console.log(total) -> 报错！
  - 若是设置值：total = 100  -> 相当于给window增加了一个属性并赋值

- 在JS中，在不进行任何特殊处理的情况下，上面的代码报错，下面的代码都不再执行

----------

### 课时4：预解释是一种毫无节操的机制

> 自从学了预解释，从此节操是路人

- 预解释时，只要用`var`声明的变量，不管所在的条件语块是否成立，统统提前声明

```javascript
if (!("num" in window)) { // ->(!true) -> false
  var num = 12  // 不执行赋值操作，但得预解释给window声明属性window.num
}
console.log(num) // -> undefined ★
```

- 预解释的时候只对‘=’左边的表达式预解释，不对‘=’的值进行预解释！匿名函数之函数表达式：把函数定义的部分当做一个值赋值给我们的变量、元素的某一个事件。

```javascript
fn1()  // -> undefined() -> Uncaught TypeError: fn1 is not a function
var fn1 = function () {
  console.log('ok')
}

fn2()  // -> ok
function fn2 () {
  console.log('ok')
}
fn2()  // ok
```

> 个人建议使用fn1函数之函数表达式定义函数，这样的好处是，函数只在代码下方执行，如果函数报错，只需要网上查即可。

- 执行函数定义的那个function在全局作用域下不进行代码预解释，当代码执行到这个位置时定义和执行一起完成了。自执行函数：定义和执行一起完成了

```javascript
(function(num) {})(100);
~function(num) {}(100);
!function(num) {}(100);
```

- 函数体中`return`下面的代码虽然不执行了，但是需要进行预解释；`return`后面跟着的都是我们的返回值，所以不进行预解释；

```javascript
function fn() {
  console.log(num)
  return function() {
  
  }
  var num = 100
}
fn()
```

- 在预解释时，如果名字已经声明过了，则不会重新再声明，但会重新赋值；在JS中，如果变量名和函数名重复了，也会覆盖！

```javascript
// window预解释执行步骤
// 声明+定义 fn = x000ff11
// 声明var fn （不会重复声明，覆盖老的fn）
// 声明（不会重复声明）+定义 fn = 0x000ff22
// -> fn = 0x000ff22
fn()  // -> 2
function fn() {console.log(1)}
fn()  // -> 2
var fn = 10
fn()  // -> 10() -> Error: fn is not a function
function fn() {console.log(1)}
fn() // 不执行了！
```

----------

### 课时5：如何查找上级作用域

- 如何查找上级作用域？

> 看当前函数是在哪个作用域下定义的，那么它的上级作用域就是谁。-->和函数在哪执行没有任何关系

```javascript
var num = 12
function fn() {
  var num = 120
  return function () {
    console.log(num)
  }
}
var f = fn()
f()

~function () {
  var num = 1200
  fn()
}
```

![Scop_Chain](http://ofx24fene.bkt.clouddn.com//img/book/Scop_Chain.svg)
