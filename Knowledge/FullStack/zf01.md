# 珠峰JS全栈培训：一、作用域深入和面向对象

### 课时1：预解释

> 基本数据类型：number、string、Boolean、null、undefined
> 引用数据类型：object（{}、[]、/^$/、Date）、function

- 当浏览器加载HTML页面的时候，首先会提供一个供全局JS代码执行的环境->全局作用域（global/window），window不仅代表当前浏览器窗口对象还代表全局作用域

- JS中定义一个函数时，首先引擎会先在内存开辟一个内存空间，然后把函数体内的代码当做**字符串**存入内存空间，最后把块内存的地址赋值给函数名。

- 预解释：在当前作用域中，JS代码执行之前，浏览器会首先默认把所有带var和function的进行提前声明或定义。

  - 理解定义和声明：
    声明（declare）：var num; -> 告诉浏览器在全局作用域中有一个num的变量了，默认值undefined
    定义（defined）：num = 12; -> 给我们声明的变量赋值
  - 对于带var和function关键字的在预解释时还是不一样的
    var -> 在预解释时只提前声明
    function -> 在预解释时提前的声明和定义都完成了
  - 预解释只发生在当前的作用域下，例如：开始只对window下的进行预解释，只有函数运行时才会对函数中的进行预解释

- JS中内存的分类
  栈内存：用来提供一个供JS代码提供的环境 -> 作用域（全局作用域、私有作用域），预解释发生在栈内存当中
  堆内存：用来存储引用数据的值 -> 对象存储的属性名和属性值，函数存储的是代码字符串

- 如何区分私有变量和全局变量？
  - 在全局作用域下声明（预解释的时候）的变量是全局变量
  - 在“私有作用域中声明的变量”和“函数的形参”都是私有变量
  - 在私有作用域中，我们的代码执行时遇到了一个变量，首先我们需要确定它是否为私有变量，如果是，则和外面作用域的变量没有任何关系；如果不是私有的，则往当前作用域的上级作用域进行查找，如果上级作用域也没有则继续往上查看，一直找到windows全局位置（作用域链）。
  
----------

## 课时2：作用域链

- 当函数执行的时候（直接目的：让函数体中的代码执行），首先会形成一个新的私有的作用域，然后按如下步骤执行：
  - 如果有形参，先给形参赋值
  - 进行私有作用域的预解释
  - 私有作用域中的代码从上到下执行
  - 函数形参的一个新的私有变量保护了里面的私有变量不受外界的干扰（外面修改不了私有的，私有的也修改不了外面的）--> “闭包”

----------

### 课时3：全局变量的细节问题
  
- 私有作用域中出现的一个变量不是私有的，则往上级作用域进行查找，上级作用域没有则继续往上级查找，一直找到window为止，如果window下也没有则：
  - 若是获取值：console.log(total) -> 报错！
  - 若是设置值：total = 100  -> 相当于给window增加了一个属性并赋值

- 在JS中，在不进行任何特殊处理的情况下，上面的代码报错，下面的代码都不再执行

----------

### 课时4：预解释是一种毫无节操的机制

> 自从学了预解释，从此节操是路人

- 预解释时，只要用`var`声明的变量，不管所在的条件语块是否成立，统统提前声明

```javascript
if (!("num" in window)) { // ->(!true) -> false
  var num = 12  // 不执行赋值操作，但得预解释给window声明属性window.num
}
console.log(num) // -> undefined ★
```

- 预解释的时候只对‘=’左边的表达式预解释，不对‘=’的值进行预解释！匿名函数之函数表达式：把函数定义的部分当做一个值赋值给我们的变量、元素的某一个事件。

```javascript
fn1()  // -> undefined() -> Uncaught TypeError: fn1 is not a function
var fn1 = function () {
  console.log('ok')
}

fn2()  // -> ok
function fn2 () {
  console.log('ok')
}
fn2()  // ok
```

> 个人建议使用fn1函数之函数表达式定义函数，这样的好处是，函数只在代码下方执行，如果函数报错，只需要网上查即可。

- 执行函数定义的那个function在全局作用域下不进行代码预解释，当代码执行到这个位置时定义和执行一起完成了。自执行函数：定义和执行一起完成了

```javascript
(function(num) {})(100);
~function(num) {}(100);
!function(num) {}(100);
```

- 函数体中`return`下面的代码虽然不执行了，但是需要进行预解释；`return`后面跟着的都是我们的返回值，所以不进行预解释；

```javascript
function fn() {
  console.log(num)
  return function() {
  
  }
  var num = 100
}
fn()
```

- 在预解释时，如果名字已经声明过了，则不会重新再声明，但会重新赋值；在JS中，如果变量名和函数名重复了，也会覆盖！

```javascript
// window预解释执行步骤
// 声明+定义 fn = x000ff11
// 声明var fn （不会重复声明，覆盖老的fn）
// 声明（不会重复声明）+定义 fn = 0x000ff22
// -> fn = 0x000ff22
fn()  // -> 2
function fn() {console.log(1)}
fn()  // -> 2
var fn = 10
fn()  // -> 10() -> Error: fn is not a function
function fn() {console.log(1)}
fn() // 不执行了！
```

----------

### 课时5：如何查找上级作用域

- 如何查找上级作用域？

> 看当前函数是在哪个作用域下定义的，那么它的上级作用域就是谁。-->和函数在哪执行没有任何关系

```javascript
var num = 12
function fn() {
  var num = 120
  return function () {
    console.log(num)
  }
}
var f = fn()
f()

~function () {
  var num = 1200
  fn()
}
```

![Scop_Chain](http://ofx24fene.bkt.clouddn.com//img/book/Scop-Chain.svg)

### 课时6：关于内存释放和作用域销毁的研究

- 堆内存：对象数据类型或者函数数据类型在定义时首先都会开辟一个堆内存，堆内存有一个引用地址，如果外面有变量等知道了这个地址，我们就说这个内存被占用了，就不能销毁了；如果我们想要让堆内存释放/销毁，只需把所有引用它的变量值赋值为null即可，如果当前的堆内存没有被任何东西占用了，那么引擎就会在空闲的时候把它销毁

```javascript
var obj1 = { name: '阿飞' }
var obj2 = obj1

obj1 = null
obk2 = null
```

- 栈内存：说白了就是作用域
  - 全局作用域：只有当页面关闭时全局作用于才会销毁
  - 私有作用域：只有函数执行会产生私有作用域。一半情况下，函数执行会形成私有作用域，当私有作用域中的代码执行完成后，我们当前作用域都会主动的进行释放和销毁。但还会有特俗情况：当前私有作用域中的部分内存被作用域以外的东西被占用了，那么当前这个作用域就不能销毁了。
  - 私有作用域不销毁情况：a、函数执行返回了一个引用类型的值，并且在函数外被一个其他东西给接收了，这种情况下一般形成的私有作用域都不会被销毁；
  - 私有作用域不销毁情况：b、在一个私有作用域中给DOM元素的事件绑定方法，一般情况下我们的私有作用域都不销毁
  - 私有作用域不销毁情况：c、fn返回的函数没有被其他东西占用，但是还需要执行一次呢，所以暂时不销毁，当返回的执行完成后，浏览器会在空闲时把它销毁。 --> 不立即销毁

```javascript
// 情况a
function fn () {
  var num = 100
  return function () { }
}
var f = fn() // fn执行后形成的这个私有作用域就不能被销毁了

// 情况b
var oDiv = document.getElementbyId("div1")
~function () {
  oDiv.onclick = function () {  }
} ()   // 当前自定义函数形成的私有作用域也不销毁

// 情况c
function fn () {
  var num  = 100
  return function () { }
}
fn()() // 首先执行fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行
```
### 课时7：作用域练习题

```javascript
function fn () {
  var i = 10
  return function (n) {
    console.log(n + (++i))
  }
}
var f = fn()
f(10)  // -> 21
f(20)  // -> 32
fn()(10)  // -> 21
fn()(20)  // -> 31
```

![chain01](http://ofx24fene.bkt.clouddn.com//img/blog/chain-pro.svg)

```javascript
function fn (i) {
  return function (n) {
    console.log(n + (i++))
  }
}
var f = fn(13)
f(12)  // -> 24
f(14)  // -> 29
fn(15)(12)  // -> 27
fn(16)(13)  // -> 29
```

### 课时8：this关键字

- JS中的this代表的是当前行为执行的主体。我们一般在JS中主要研究的都是函数中的this。
- JS中的context代表的是当前执行的环境（区域）
- this是谁和函数在哪里定义的和在哪执行的都没任何关系；如何区分this呢？
  - 函数执行时，如果函数名前有`.`的话，`.`前面是谁this就是谁；没有的话，this就是window（全局对象）
  - 自执行函数中的this永远是window
  - 给DOM元素的某一事件绑定方法，当事件触发时，执行对应的方法，方法中的this就是当前元素
  

```javascript
function fb () {
  console.log(this)
}

var obj = {fn: fn}
fn() // -> this is window
obj.fn() // -> this is obj

documnet.getElementById("div1").onclick = fn;
documnet.getElementById("div1").onclick = function () { 
  //但函数作用于内的this为'#div'
  fn() // -> this is window
}
```

### 课时9：综合练习题

```javascript
var num = 20
var obj = {
  num: 30,
  fn: (function (num) {
    this.num *=3
    num += 15
    var num = 45
    return function () {
      this.num *= 4
      num += 20
      console.log(num)
    }
  })(num)
}
var fn = obj.fn
fn()
obj.fn()
console.log(window.num, obj.num)
```

![09](http://ofx24fene.bkt.clouddn.com//img/blog/zhufeng09.svg)

### 课时10：综合实战题

```javascript
var oBtn = document.getElementById('button')
var oCount = document.getElementById('count')

// 方法一：全局作用域法
var count = 0
oBtn.onclick = function () {
    oCount.innerHTML = ++count
} // 弊端：全局变量污染

// 方法二：私有作用域法之自执行函数
~function () {
    var count = 0
    oBtn.onclick = function () {
        oCount.innerHTML = ++count
    }
}() // 弊端：私有作用域不销毁，浪费一丁点内存

// 方法三：私有作用域法之直接绑定自执行函数
oBtn.onclick = (function () {
    var count = 0
    return function () {
        oCount.innerHTML = ++count
    }
})()  // 弊端：私有作用域不销毁，浪费一丁点内存

// 方法四：innerHtml法
oBtn.onclick = function () {
    oCount.innerHTML++
}  // 弊端：利用innerHtml方法读写，再加字符串转数字，最后渲染页面

// 方法五：自定义属性法
oBtn.count = 0 //在btn上设置一个自定义属性
oBtn.onclick = function () {
    oCount.innerHTML = ++this.count
}  // 推荐

```

### 课时11：单例模式

- 对象数据类型的作用
  - 把描述同一个事物（同一个对象）的属性和方法放在一个内存空间下，起到了分组的作用，这样不同事物之间的属性名相同，相互也不会发生冲突
  - 我们把这种分组编写代码的模式叫作“单例模式”
  - 在单利模式中我们把person1或者person2也叫做“命名空间”
  
```javascript
var person1 = { name: 'xxx' }
var person2 = { name: 'yyy' }
```

> 单例模式是一种项目开发中经常使用的模式，因为项目中我们可以使用单例模式来进行“模块化开发”

- “模块化开发”对于一个相对来说较大的项目，需要多人协同开发的，我们一般情况下会根据当前项目的需求划分成几个功能板块，每个人负责开发一部分，同时开发，最后把每个人开发的代码进行合并。

### 课时12：工厂模式

- 单例模式虽然解决了分组作用，但是不能实现批量生产，属于手工作业模式 -> 需要改进成”工厂模式“
- 把实现同一件事情的相同代码放到一个函数中，以后如果再想实现这个功能，不需要重新编写这些代码，只需要执行这个工厂函数即可 -> ”函数封装“ --> ”低耦合高内聚“：减少冗余代码，提高代码的复用率
- JS是一门轻量级的脚本”编程语言“（HTML+CSS不属于编程语言，属于标记语言）
- 大多的编程语言都是面向对象开发的 -> 类的继承、封装、多态
  - 继承：子类继承父类中的属性和方法
  - 多态：当前方法的多种形态。后台语言中：多态包含重载和重写
  
- JS中不存在重载，方法名一样的话，后面的会把前面的覆盖，最后只保留最后一个。
  - JS中有一个操作类似重载但不是重载：我们可以在函数体里根据传递参数的不一样，实现不同的功能。
  - 重写：子类重写父类的方法
  
> 说白了工厂模式就是一个“破函数”

### 课时13：构造函数模式基础

#### 构造函数模式和工厂模式的区别
 
- 执行的时候：
   - 普通函数执行 -> `creatorPerson()`
   - 构造函数执行 -> `New creatorPerson()`，此时creatorPerson就是类名，返回实例。

- 在函数代码执行的时候
  - 相同点：都是形成一个私有的作用域，然后执行步骤 形参赋值->预解释->代码从上到下执行（类和普通函数一样，它也有普通函数的一面）
  - 不同点：在代码执行之前，不用自己在手动创建obj对象，浏览器会默认自动创建一个对象数据类型的值（这个对象其实就是我们当前类的一个实例）；接下来代码从上到下执行，以当前的实例为执行的主体（this代表的就是当前），然后分别的把属性名和属性值赋值给当前实例；最后浏览器会默认自动把创建的实例返回。
  
```javascript
// 工厂模式
function createPerson (name, age) {
  var obj = {}  // 这里创建对象
  obj.name = name
  obj.age = age
  return obj  // 这里返回这个对象
}

function CreatePerson (name, age) {
  // 这里不需要创建
  this.name = name
  this.age = age
  // 这里不需要返回
}
```

> 1.JS中所有的类都是函数数据类型，他通过new执行成一个类，但它本事也是一个普通的函数；JS中所有的实例都是对象数据类型
2.在构造函数模式中，类中（函数体中）出现的this均指当前类的一个实例
3.两个实例都是类的实例，所有都有用相同的方法，但是不同实例之间的方法都是不一样的。在类中给实例添加的属性都属于这个实例的私有属性，实例和实例之间是单独的个体，所以私有的属性之间不相等。

```javascript
var res = CreatePerson('szy', 18) // 函数方式执行构造函数：首先res接收到的是undefined，因为没return。其次是构造函数中的`this`是全局的window对象。
```

### 课时14：构造函数模式扩展

```javascript
function Fn () {
  var num = 4
  this.x = 100 // 此时，this为当前实例f1
  this.get = function () {
    console.log(this.x) // 而这个this就需要调用时才知道是谁
  }
}

var f1 = new Fn
f1.getX() // -> 方法中的this是f1 -> 100
f1.num // -> undefined
var ss = f1.getX
ss() // -> 方法中的this是window -> undefined
```


- 在构造函数模式中，`new Fn()`执行，如果Fn没有参数，则后面的小括号可以省略`new Fn`
- this的问题：在类中出现的this.xxx的this都是当前类的实例，而某一属性值（方法）中若出现this则需要看方法执行的时候，前面是否有'.'才能知道this是谁（谁调用）
- 类也有普通函数的一面，当函数执行的时候，`var num`其实只是当前形成私有作用域中的私有变量而已，它和我们的f1这个实例没有任何关系；只有`this.xxx=yyy`才相当于给f1这个实例添加私有属性和方法，才和我们f1有关系

```javascript
function Fn () {
  this.x = 100
  return { name: "szy" }
}

var f1 = new Fn
console.log(f1)  // -> {name: "szy"}
```

- 在构造函数模式中，浏览器会默认的把我们实例返回（返回的是一个对象数据类型的值），如果我们手动写了return返回的话：
  - 若返回的是一个基本数据类型的值，则当前实例是不变的，还是照样返回这个实例，如`return 100`
  - 若返回的是一个引用数据类型的值，则当前要返回的这个实例会被我们手动设置的对象给替换，如`return { name: "szy" }`
  
```javascript
function Fn () {
  this.x = 100
}

var f1 = new Fn
console.log(f1 instanceof Fn)  // -> true
console.log(f1 instanceof Array)  // -> false
console.log(f1 instanceof Object)  // -> true 因为所有的实例都是对象数据类型的，而每个对象数据类型都是Object这个内置类的一个实例，所以f1也是它的一个实例。对于检测数据类型来说，typeof有自己的局限性，不能细分object下的对象、数组、正则等...
```

- 检查某个实例是否是某个类的实例：**instanceof**

```javascript
var f1 = new Fn
var f1 = new Fn
```

- f1和f2都是Fn这个类的实例，都拥有x和getX两个属性，但是这两个属性是各自的私有属性，用`===`判断的结果是`false`
  - `in`：检测某一个属性名是否存在于某个对象(attrName in object)，不管是私有属性还是共有属性，只要存在，用`in`来检测都是true
  - `hasOwnProperty`：用来检测某一个属性是否为这个对象的“自有(私有)属性”，这个方法只能检测自有属性
  
> 思考：检测某一个属性是否为这个对象的“共有属性”：hasPubProperty
原理：检测是否为对象的属性，并检测不是对象的私有属性即可。

```javascript
function hasPubProperty(obj, attr) {
  return (attr in obj) && (!obj.hasOwnProperty(attr))
}
```

- `isPrototypeOf`

### 课时15：原型链模式基础

> 基于构造函数模式的原型链模式解决了 方法或者属性公有的问题 -> 把实例之间相同的属性和方法提取出来成公有的属性和方法 -> 想让谁公有就把它放在`.prototype`属性上即可

- 每一个函数数据类型（普通函数、类）都有一个天生的自带属性：`prototype`（原型），并且这个属性是一个对象数据类型的值
- 并且在`prototype`上浏览器天生给它加了一个属性`constructor`（构造器），属性值就是当前的函数(类)本身
- 每一个对象数据类型(普通对象、实例、prototype、数组、正则、Data...)也天生自带一个属性：`__proto__`，其属性值就是当前实例所属类的原型(prototype)

```javascript
function Fn() {
  this.x = 100
}
Fn.prototype.getX = function () { console.log(this.x) }

var f1 = new Fn
var f2 = new Fn

console.log(Fn.prototype.constructor === Fn)  // -> true
```

![prototype chain base](http://ofx24fene.bkt.clouddn.com//img/blog/prototype%20chain%20base.svg)
