# 珠峰JS全栈培训：一、作用域深入和面向对象

### 课时1：预解释

> 基本数据类型：number、string、Boolean、null、undefined
> 引用数据类型：object（{}、[]、/^$/、Date）、function

- 当浏览器加载HTML页面的时候，首先会提供一个供全局JS代码执行的环境->全局作用域（global/window），window不仅代表当前浏览器窗口对象还代表全局作用域

- JS中定义一个函数时，首先引擎会先在内存开辟一个内存空间，然后把函数体内的代码当做**字符串**存入内存空间，最后把块内存的地址赋值给函数名。

- 预解释：在当前作用域中，JS代码执行之前，浏览器会首先默认把所有带var和function的进行提前声明或定义。

  - 理解定义和声明：
    声明（declare）：var num; -> 告诉浏览器在全局作用域中有一个num的变量了，默认值undefined
    定义（defined）：num = 12; -> 给我们声明的变量赋值
  - 对于带var和function关键字的在预解释时还是不一样的
    var -> 在预解释时只提前声明
    function -> 在预解释时提前的声明和定义都完成了
  - 预解释只发生在当前的作用域下，例如：开始只对window下的进行预解释，只有函数运行时才会对函数中的进行预解释

- JS中内存的分类
  栈内存：用来提供一个供JS代码提供的环境 -> 作用域（全局作用域、私有作用域），预解释发生在栈内存当中
  堆内存：用来存储引用数据的值 -> 对象存储的属性名和属性值，函数存储的是代码字符串

- 如何区分私有变量和全局变量？
  - 在全局作用域下声明（预解释的时候）的变量是全局变量
  - 在“私有作用域中声明的变量”和“函数的形参”都是私有变量
  - 在私有作用域中，我们的代码执行时遇到了一个变量，首先我们需要确定它是否为私有变量，如果是，则和外面作用域的变量没有任何关系；如果不是私有的，则往当前作用域的上级作用域进行查找，如果上级作用域也没有则继续往上查看，一直找到windows全局位置（作用域链）。
  
----------

## 课时2：作用域链

- 当函数执行的时候（直接目的：让函数体中的代码执行），首先会形成一个新的私有的作用域，然后按如下步骤执行：
  - 如果有形参，先给形参赋值
  - 进行私有作用域的预解释
  - 私有作用域中的代码从上到下执行
  - 函数形参的一个新的私有变量保护了里面的私有变量不受外界的干扰（外面修改不了私有的，私有的也修改不了外面的）--> “闭包”

----------

### 课时3：全局变量的细节问题
  
- 私有作用域中出现的一个变量不是私有的，则往上级作用域进行查找，上级作用域没有则继续往上级查找，一直找到window为止，如果window下也没有则：
  - 若是获取值：console.log(total) -> 报错！
  - 若是设置值：total = 100  -> 相当于给window增加了一个属性并赋值

- 在JS中，在不进行任何特殊处理的情况下，上面的代码报错，下面的代码都不再执行

----------

### 课时4：预解释是一种毫无节操的机制

> 自从学了预解释，从此节操是路人

- 预解释时，只要用`var`声明的变量，不管所在的条件语块是否成立，统统提前声明

```javascript
if (!("num" in window)) { // ->(!true) -> false
  var num = 12  // 不执行赋值操作，但得预解释给window声明属性window.num
}
console.log(num) // -> undefined ★
```

- 预解释的时候只对‘=’左边的表达式预解释，不对‘=’的值进行预解释！匿名函数之函数表达式：把函数定义的部分当做一个值赋值给我们的变量、元素的某一个事件。

```javascript
fn1()  // -> undefined() -> Uncaught TypeError: fn1 is not a function
var fn1 = function () {
  console.log('ok')
}

fn2()  // -> ok
function fn2 () {
  console.log('ok')
}
fn2()  // ok
```

> 个人建议使用fn1函数之函数表达式定义函数，这样的好处是，函数只在代码下方执行，如果函数报错，只需要网上查即可。

- 执行函数定义的那个function在全局作用域下不进行代码预解释，当代码执行到这个位置时定义和执行一起完成了。自执行函数：定义和执行一起完成了

```javascript
(function(num) {})(100);
~function(num) {}(100);
!function(num) {}(100);
```

- 函数体中`return`下面的代码虽然不执行了，但是需要进行预解释；`return`后面跟着的都是我们的返回值，所以不进行预解释；

```javascript
function fn() {
  console.log(num)
  return function() {
  
  }
  var num = 100
}
fn()
```

- 在预解释时，如果名字已经声明过了，则不会重新再声明，但会重新赋值；在JS中，如果变量名和函数名重复了，也会覆盖！

```javascript
// window预解释执行步骤
// 声明+定义 fn = x000ff11
// 声明var fn （不会重复声明，覆盖老的fn）
// 声明（不会重复声明）+定义 fn = 0x000ff22
// -> fn = 0x000ff22
fn()  // -> 2
function fn() {console.log(1)}
fn()  // -> 2
var fn = 10
fn()  // -> 10() -> Error: fn is not a function
function fn() {console.log(1)}
fn() // 不执行了！
```

----------

### 课时5：如何查找上级作用域

- 如何查找上级作用域？

> 看当前函数是在哪个作用域下定义的，那么它的上级作用域就是谁。-->和函数在哪执行没有任何关系

```javascript
var num = 12
function fn() {
  var num = 120
  return function () {
    console.log(num)
  }
}
var f = fn()
f()

~function () {
  var num = 1200
  fn()
}
```

![Scop_Chain](http://ofx24fene.bkt.clouddn.com//img/book/Scop-Chain.svg)

### 课时6：关于内存释放和作用域销毁的研究

- 堆内存：对象数据类型或者函数数据类型在定义时首先都会开辟一个堆内存，堆内存有一个引用地址，如果外面有变量等知道了这个地址，我们就说这个内存被占用了，就不能销毁了；如果我们想要让堆内存释放/销毁，只需把所有引用它的变量值赋值为null即可，如果当前的堆内存没有被任何东西占用了，那么引擎就会在空闲的时候把它销毁

```javascript
var obj1 = { name: '阿飞' }
var obj2 = obj1

obj1 = null
obk2 = null
```

- 栈内存：说白了就是作用域
  - 全局作用域：只有当页面关闭时全局作用于才会销毁
  - 私有作用域：只有函数执行会产生私有作用域。一半情况下，函数执行会形成私有作用域，当私有作用域中的代码执行完成后，我们当前作用域都会主动的进行释放和销毁。但还会有特俗情况：当前私有作用域中的部分内存被作用域以外的东西被占用了，那么当前这个作用域就不能销毁了。
  - 私有作用域不销毁情况：a、函数执行返回了一个引用类型的值，并且在函数外被一个其他东西给接收了，这种情况下一般形成的私有作用域都不会被销毁；
  - 私有作用域不销毁情况：b、在一个私有作用域中给DOM元素的事件绑定方法，一般情况下我们的私有作用域都不销毁
  - 私有作用域不销毁情况：c、fn返回的函数没有被其他东西占用，但是还需要执行一次呢，所以暂时不销毁，当返回的执行完成后，浏览器会在空闲时把它销毁。 --> 不立即销毁

```javascript
// 情况a
function fn () {
  var num = 100
  return function () { }
}
var f = fn() // fn执行后形成的这个私有作用域就不能被销毁了

// 情况b
var oDiv = document.getElementbyId("div1")
~function () {
  oDiv.onclick = function () {  }
} ()   // 当前自定义函数形成的私有作用域也不销毁

// 情况c
function fn () {
  var num  = 100
  return function () { }
}
fn()() // 首先执行fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行
```
### 课时7：作用域练习题

```javascript
function fn () {
  var i = 10
  return function (n) {
    console.log(n + (++i))
  }
}
var f = fn()
f(10)  // -> 21
f(20)  // -> 32
fn()(10)  // -> 21
fn()(20)  // -> 31
```

![chain01](http://ofx24fene.bkt.clouddn.com//img/blog/chain-pro.svg)

```javascript
function fn (i) {
  return function (n) {
    console.log(n + (i++))
  }
}
var f = fn(13)
f(12)  // -> 24
f(14)  // -> 29
fn(15)(12)  // -> 27
fn(16)(13)  // -> 29
```

### 课时8：this关键字

- JS中的this代表的是当前行为执行的主体。我们一般在JS中主要研究的都是函数中的this。
- JS中的context代表的是当前执行的环境（区域）
- this是谁和函数在哪里定义的和在哪执行的都没任何关系；如何区分this呢？
  - 函数执行时，如果函数名前有`.`的话，`.`前面是谁this就是谁；没有的话，this就是window（全局对象）
  - 自执行函数中的this永远是window
  - 给DOM元素的某一事件绑定方法，当事件触发时，执行对应的方法，方法中的this就是当前元素
  

```javascript
function fb () {
  console.log(this)
}

var obj = {fn: fn}
fn() // -> this is window
obj.fn() // -> this is obj

documnet.getElementById("div1").onclick = fn;
documnet.getElementById("div1").onclick = function () { 
  //但函数作用于内的this为'#div'
  fn() // -> this is window
}
```

### 课时9：综合练习题

```javascript
var num = 20
var obj = {
  num: 30,
  fn: (function (num) {
    this.num *=3
    num += 15
    var num = 45
    return function () {
      this.num *= 4
      num += 20
      console.log(num)
    }
  })(num)
}
var fn = obj.fn
fn()
obj.fn()
console.log(window.num, obj.num)
```

![09](http://ofx24fene.bkt.clouddn.com//img/blog/zhufeng09.svg)

### 课时10：综合实战题

```javascript
var oBtn = document.getElementById('button')
var oCount = document.getElementById('count')

// 方法一：全局作用域法
var count = 0
oBtn.onclick = function () {
    oCount.innerHTML = ++count
} // 弊端：全局变量污染

// 方法二：私有作用域法之自执行函数
~function () {
    var count = 0
    oBtn.onclick = function () {
        oCount.innerHTML = ++count
    }
}() // 弊端：私有作用域不销毁，浪费一丁点内存

// 方法三：私有作用域法之直接绑定自执行函数
oBtn.onclick = (function () {
    var count = 0
    return function () {
        oCount.innerHTML = ++count
    }
})()  // 弊端：私有作用域不销毁，浪费一丁点内存

// 方法四：innerHtml法
oBtn.onclick = function () {
    oCount.innerHTML++
}  // 弊端：利用innerHtml方法读写，再加字符串转数字，最后渲染页面

// 方法五：自定义属性法
oBtn.count = 0 //在btn上设置一个自定义属性
oBtn.onclick = function () {
    oCount.innerHTML = ++this.count
}  // 推荐

```
