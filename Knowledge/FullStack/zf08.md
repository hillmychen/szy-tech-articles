# 珠峰前端全栈培训第八周：JS部分专题总结和技能提升

[TOC]

## 课时161：原型链模式 常用的六种继承

```javascript
var num1 = 1;   // 用字面量创造出来的并不算是真正的实例，只是基本类型的值。这是js的弱类型语言独有的
var num2 = new Number(1);   // 是真正的实例

typeof num1;    // -> number
typeof num2;    // -> object

num1 instanceof Number;     // -> false
num2 instanceof Number;     // -> true

// num2.__proto__ -> Number -> .__proto__ -> Object，所以typeof的值是object，也所以instanceof为true
```

- `for-in`循环遍历对象中所有(私有和公有)的可枚举属性。可以用`myObj.propertyIsEnumerable('xname')`判断是否为可枚举属性，当然也可以用老方法`hasOwnProperty()`判断。

```javascript
var obj = {
    constructor: Fn,
    getX: function() {
    }
};

function Fn() {
}
Fn.prototype = obj;  // 如果没这句代码时f.constrctor指向Fn本身，这是因为引擎会默认为Fn的原型上添加一个constructor属性 Fn.prototype.constructor === Fn (true)
// obj好比一个堆内存开辟出来的作用域0x00ff00，此时Fn.prototype也绑定到了0x00ff00地址上。

Fn.prototype.sum = function () { };
obj.sum();      // -> 可以调用
obj.add();      // -> 给obj对象添加方法
Fn.prototype.add();  // 竟然Fn的原型上也可以调用，那就只说明了一个问题：0x00ff00地址绑定成功

var f = new Fn(); 
f.constrctor;  // -> obj
```

- 克隆对象

```javascript
var obj = { name: 'szy' };
var obj1 = obj  // 不是克隆，只是将内存地址给它而已

// 简单克隆当前对象的私有属性的方法
for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
        obj1[key] = obj[key];
    }
}

// 还可以用es5提供的方法
var obj2 = Object.create(obj);
// 但问题时，该方法将obj的属性全放在obj2的__proto__属性上了，也就是说原型链加长了一截。
// 但是obj添加新属性，也会影响到obj2，还是整不成！
```

- Object.create(proObj)：创建一个新对象，且把第一个参数proObj作为这个新对象的原型。模拟实现如下：

```javascript
function object(o) {
    // 创建一个空的构造函数
    function Fn() {};
    // 修改构造函数的原型指向传入的对象
    Fn.prototype = o;
    // 实例化这个构造函数得到一个新的对象，这个对象的原型已经被改为o了
    return new Fn;
}
```

### 第一种：原型继承

我们来看一个div的原型链：

    #div.box.__proto__ --> HTMLDivElement.prototype --> HTMLElement.prototype --> Element.protorype --> Node.protorype --> EventTarget.protorype --> Object.protorype

- 模拟原型链

```javascript
function myObject() { }

myObject.prototype = {
    constructor: myObject,
    hasOwnProperty: function() { },
    toString: function() { }
}

function myEventTarget() {
    addEventListener: function() { }
}

myEventTarget.prototype = new myObject();

function myNode() {
    
}

myNode.prototype = new myEventTarget();

myNode.prototype.createElement = function() { };

var nn = new myNode;
```

- “原型继承”是JavaScript中最常见的一种继承方式
  - 子类B想要继承父类A中所有属性和方法(私有+公有)
  - 实现：`B.prototype = new A();`，如果需要改B的constructor指向`B.prototype.constructor = B`
  - 特点：它是把父类中私有和公有的都继承到子类原型上，也就称为子类的公有的
  - 核心：原型继承并不是把父类中的属性和方法克隆一份一模一样的给B，而是让B和A之间增加了原型链的连接，以后B的实例想要A中的某方法时，需要一级一级的上原型链上查找
  - 重写：JS中的重写是指，子类通过`__proto__`修改父类的属性或者方法。但这个改写后所有父类的实例都受影响，这是因为JS是原型机制所造成的。

### 第二种：call继承

- call继承：把父类**私有**的属性和方法克隆一份一模一样的作为子类***公有***的属性。这个的要求就是父类中要使用this定义属性。

```javascript
function A() {
    // 好比n.x = 100;
    this.x = 100;
}
A.prototype.getX = function() {
    console.log(this.x);
}

function B() {
    // this -> n
    A.call(this);
    // 把A类中的this变成了n
}

var n = new B;
console.log(n.x);       // -> 100
n.getX();    // -> undefined
```

### 第三种：冒充对象继承

- 冒充对象继承：把父类**私有+公有**属性克隆一份一模一样的作为子***类私***有的属性。

```javascript
function A() {
    // 好比n.x = 100;
    this.x = 100;
}
A.prototype.getX = function() {
    console.log(this.x);
}

function B() {
    // this --> n
    var tmp = new A;
    for (var key in tmp) {
        // 遍历A实例tmp所有可遍历属性
        this[key] = tmp[key];
    }
    tmp = null; // 清
}

var n = new B;
console.log(n.x);       // -> 100
n.getX();    // -> 100
```

### 第四种：混合模式继承

> 原型继承+call继承：好比A执行了两次，第一次把A的私有属性放到B的私有上，第二次把A的私有+公有属性放在B的公有上。

```javascript
function A() {
    // 好比n.x = 100;
    this.x = 100;
}
A.prototype.getX = function() {
    console.log(this.x);
}

function B() {
    // this --> n
    A.call(this);
}
B.prototype = new A;
B.prototype.constructor = B;

var n = new B;
console.log(n.x);       // -> 100
n.getX();    // -> 100
```

### 第五种：寄生组合式继承

> 父类私有属性放子类私有属性上，父类原型共有属性放子类原型共有上。

```javascript
function A() {
    // 好比n.x = 100;
    this.x = 100;
}
A.prototype.getX = function() {
    console.log(this.x);
}

function B() {
    // this --> n
    A.call(this);  // 将A的私有放B的私有
}
B.prototype = createObject(A.prototype); // 只把父类的原型给子类原型
B.prototype.constructor = B;
// 因为这个方法n的原型上不直接是A，中间隔了一层空的，然后才到A的原型
var n = new B;
console.log(n.x);       // -> 100
n.getX();    // -> 100
// 兼容IE
function createObject(o) {
    function Fn() {};
    Fn.prototype = o;
    return new Fn;
}
```

### 第六种：中间类继承法

> 核心原理就是修改目标实例的原型指向：`arguments.__proto__ = Array.prototype;`

小栗子，求相对平均数：去掉一个最大值和一个最小值，然后求剩余数的平均数。

```javascript
function avgFn() {
    Array.prototype.sort.call(arguments, function(a, b) {
        return a - b;
    });
    Array.prototype.pop.call(arguments); // 移除数组最后一个元素
    [].__proto__.shift.call(arguments);  // 移除数组第一个元素
    return (eval(Array.prototype.join.call(arguments, '+')) / arguments.length).toFixed(2);
}

console.log(avgFn(30,20,10,30,40,50,10,20,30));
```

> 观察`arguments`和数组实例区别仅为原型链上不一样，arguments直接指向Object原型，而Array的实例是先指向Array的原型再指向Object原型。所以我们直接修改arguments的原型先指向Array的原型再指向Object的原型即可。

```javascript
function avgFn() {
    arguments.__proto__ = Array.prototype;
    arguments.sort(function(a, b) {
        return a - b;
    });
    arguments.pop();
    arguments.shift();
    return (eval(arguments,join('+')) / arguments.length).toFixed(2);
}

console.log(avgFn(30,20,10,30,40,50,10,20,30));
```

----------

## 课时162：js检测兼容的三种方式

- 获取元素的某一个具体的样式属性值

```javascript
// 1. 元素.style.属性名
// -> 这个方法需要把我们元素的样式都写在行内样式才可以获取，如果写在样式表中就无法获取
// -> 在真实项目中，这种方式不常用，因为我不能为了获取值而把所有样式都写在行内上(无法实现HTML和CSS的分离)
console.log(box.style.height);

// 2. 使用window.getComputedStyle()方法，获取通过浏览器渲染计算过的元素样式。
// -> 所有经过浏览器渲染计算过的样式：只要当前的元素标签可以在页面中呈现出现，那么它所有的样式都是经过浏览器渲染计算过的。

// 3. getComputedStyle方法在IE6~8总不兼容，用box.currentStyle属性来获取渲染后的样式值

// 兼容方法
function getCss(curEle, attr) {
    var val = null;
    try {
        val = window.getComputedStyle(curEle, null)[attr];
    } catch(e) {
        val = curEle.currentStyle[attr];
    }
    return val;
}

// 使用try...catch处理兼容时，每次都需要执行一次try内容，消耗性能。

// 兼容升级1：使用in判断是否存在此属性
function getCss1(curEle, attr) {
    var val = null;
    if (getComputedStyle in window) { // true说明有此属性
    // if (window.getComputedStyle) { // 获取属性值，得到函数后转换Boolean时得到true，两次转换哦
        val = window.getComputedStyle(curEle, null)[attr];
    } else {
        val curEle.currentStyle[attr];
    }
    return val;
}

// 兼容升级2： 使用window.navigator.userAgent判断是否是IE
function getCss1(curEle, attr) {
    var val = null;
    if (/MSIE (6|7|8)/.test(navigator.userAgent)) { 
        val = curEle.currentStyle[attr];
    } else {
        val = window.getComputedStyle(curEle, null)[attr];
    }
    return val;
}
```

- 在Chrome中，苏若么给某个元素设置背景色时，浏览器渲染时会自动给一个`rgba(0,0,0,0)`黑色纯透明的背景色。

- 关于JavaScript中检测处理兼容的三种常用方法：
  - try...catch
  - ★通过判断属性名是否存在
  - 通过navigator判断浏览器信息处理兼容

> 写css的时候第一步初始化默认样式，避免浏览器之间的差异。不仅如此，而且所写默认样式对于JS以后获取到的结果统一也是有一定帮助的。

- getCss()方法升级：把获取到的样式值去掉“单位”

```javascript
function getCss(curEle, attr) {
    var val = null, reg = null;
    if (getComputedStyle in window) {
        val = window.getComputedStyle(curEle, null)[attr];
    } else {
        val = curEle.currentStyle[attr];
    }
    // 配置正则，只要正负数加单位的值
    reg = /^(-?\d+(\.\d+)?)(px|pt|rem|em)?$/;
    // 匹配成功就转换，不成功就返回原始值
    return reg.test(val) ? parseFloat(val) : val;
    // return parseFloat(val); 不可能简单的去单位，因为还有复合值类型，不能用！
}
```

- getCss()方法第二次升级：有些样式在不同浏览器中是不兼容的，

```javascript
function getCss(curEle, attr) {
    var val = null, reg = null;
    if (getComputedStyle in window) {
        val = window.getComputedStyle(curEle, null)[attr];
    } else { // 如果是IE环境
        if (attr === 'opacity') {
            val = curEle.currentStyle['filter'];
            // alpha(opacity=80)
            // 捕获小正则[1]的值
            reg = /^alpha\(opacity=(\d+\.\d+)?\)$/i;
            val = reg.test(val) ? reg.exec(val)[1]/100 : 1;
        }
        val = curEle.currentStyle[attr];
    }
    // 配置正则，只要正负数加单位的值
    reg = /^(-?\d+(\.\d+)?)(px|pt|rem|em)?$/;
    // 匹配成功就转换，不成功就返回原始值
    return reg.test(val) ? parseFloat(val) : val;
    // return parseFloat(val); 不可能简单的去单位，因为还有复合值类型，不能用！
}
console.log(getCss(box, 'opacity'));
```

## 课时163：数据类型检测的四种方式

### `typeof`用来检测数据类型的运算符

- 使用`typeof`检测数据类型，首先返回的值是一个字符串，其次字符串中包含了基本数据类型
- "number"、"string"、"boolean"、"undefined"、"null"、"object"
- 局限性：`typeof null` --> "object"；`typeof undefined` --> "undefined"
- 小栗子：`console.log(typeof typeof typeof function() {})`  -> "string"，因为JS优先级关系，先从最右边开始走起，走到typeoif function() {}时得到"function"，之后再来几个typeof都是"string"
- 局限性2：不能具体细分到底是数组还是正则，还是对象中的其他值，因为使用其检测后，对于对象数据类型中的左右的值，最后返回的结果都是“object”

```javascript
// if (typeof num === 'undefined') {
//     num = 0
// }
num = num || 0;

// typeof callback === 'function' ? callback() : null;
callback && callback();
```

### `instancof` 检测某一个实例是否属于某个类

- 第一个局限性：不能用来检测和处理字面量方式创建出来的基本数据类型
  - 对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建出来的结果又一定区别。从严格意思上来讲，只有实例创建出来的结果才是标准的对象数据类型，也是标准的Number类的实例；对于字面量方式创建出来的结果是基本数据类型，不是严谨的实例，但是由于JS的松散特点，导致了可以使用Number.prototype原型上的方法； 

```javascript
console.log(1 instanceof Number);    // -> false
console.log(new Number(1) instanceof Number);   // -> true
```

- 第二个局限性：`instancof`的检测特性：只要在当前实例的原型链上，我们用其检测的结果都是true

```javascript
var ary = [];
console.log(ary instanceof Array);  // -> true
console.log(ary instanceof Object); // -> true

function fn() {};
console.log(fn instanceof Function);    // -> true
console.log(fn instanceof Object);    // -> true

var oDiv = document.getElementById('#myDiv');
// oDiv -> HTMLDivElement.prototype --> HTMLElement.prototype --> Element.prototype --> Node.prototype --> EventTarget.prototype --> Object.prototype
oDiv instanceof Node;  // --> true

function Fn() {};
Fn.prototype = new Array;
var f = new Fn; // 原型继承：让子类的原型等于父类的一个实例
console.log(f instanceof Array);  // --> true
// 结论：在类的原型继承中，我们最后检测出来的结果未必准备
// 练习：写一个类，实现创建类数组(index & length)，但是可以用数组的方法。在它原型链上扩张一层Array.prototype就行。
```

### `constructor`构造函数检测，作用和instanceof非常相似

```javascript
var obj = [];
console.log(obj.constructor === Array);  // -> true
console.log(obj.constructor === Regex);  // -> false

// 说明constructor可以用来检测基本数据类型
console.log(1.constructor === Number); // -> true

// constructor不能检测Object，这点和instanceof不一样。
var reg = /^\d$/
console.log(reg.constructor === RegExp); // -> true
console.log(reg.constructor === Object); // -> false
```

- `constructor`检测的局限性：对类的原型进行重写时，很有可能把之前的constructor覆盖了，这样就检测不出来正确的结果。

```javascript
function Fn() {}
Fn.prototype = new Array;
var f = new Fn;
console.log(f.constructor);  // -> Array
// 但实际上f并不是真正的数组
```
