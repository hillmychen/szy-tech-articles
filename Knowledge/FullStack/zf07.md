# 珠峰前端全栈培训第七周：ajax jsonp node基础及项目实战开发

[TOC]

## 课时125：常用的dos命令

> 我接触Windows系统快19年、系统维护超过6年，基本不需要扫盲了，但还是简单记录下~

- `ipconfig`、`ipconfig -all`
- `ping`
- `ctrl + c`
- `exit`
- `cls` 清屏
- `cd ../` 返回上一级目录、`cd ./` 当前目录、`cd /` 返回当前磁盘根目录
- `e:` 直接进入E盘
- `cd dirname`
- `dir`

## 课时126：客户端和服务器端的交互模式

- W3C
一个指定开发规范的非盈利性组织 HTML/HTML5/CSS/CSS3/ECMAScript...的规范都是由这个组织制定和管理的。
我们作为一个开发者开发的页面，也是按照规范来开发的
浏览器开发商一般也是按照W3C的规范开发浏览器的引擎
但是浏览器厂商总要凸显自己的与众不同，有些厂商把W3C规范实现后，又增加了一些自己独有的好东西(谷歌)，这就导致了我们在写代码的时候经常写：`-webkit-xxxx:xxx`
但是又有些厂商，为了凸显自己的不一样，就是不按照规范来，而走自己的一套(IE)，这也就导致编写的代码想要兼容所有浏览器就需要写多套代码：如chrome的`getComputedStyle`、IE为`currentStyle`

- 通过在Chrome的Network中观看，我们发现当第一次把html源代码请求回来时，浏览器开始按照自己的引擎渲染，在渲染过程中我们还会出现重新向服务器请求CSS、JS、IMG....，每次的请求步骤和HTML的步骤是一样的；如果请求资源次数太多，页面打开的速度和渲染的速度就会变慢，所以我们以后在页面优化的方法中，首先要做的就是减少资源请求数(减少HTTP请求)
  - CSS合并成一个 或者 CSS不是很多的话我们采用内联样式
  - JS合并成一个 或者采用内联式
  - 图片合并(雪碧图技术/CSS Sprite) 或者 图片延迟加载
  - Ajax请求和资源文件的请求原理也是一样

## 课时127：url和http基础知识

- URI、URL、URN

URI = URL + URN (统一资源标识符/统一资源信息)

URL：统一资源定位符
`https://v.qq.com/index.html?name=jerry&age=18#target`
`#target`：URL的hash(锚点定位) 

## 课时128：初步了解node

- JS是一门“运行在客服端(即浏览器)”的“轻量级”的脚本编程语言

- Node是一个环境，供JS代码执行的环境，我们可以把它等价于浏览器，只不过我们一般都会把Node这个环境安装到服务端，这样的话我们就可以在服务器端使用JS编写程序了，也就是说JS不仅仅是客户端语言也是服务端语言

- Node采用的是谷歌V8引擎渲染JS（运行速度快、稳定、不需要考虑兼容）
- 浏览器中的全局JS对象是window，而Node环境下的全局JS对象是Global
- 浏览器是安装在客户端的，为了保护客户端的安全，基本上不可能提供用JS对客户端电脑磁盘上的文件进行操作的功能；但Node环境中提供了对应的I/O操作，我们使用JS可以对服务器上的磁盘文件进行操作。

- JavaScript分为三部分：ECMAScript、DOM、BOM
  - `JavaScript` 实现了ECMAScript的语法规范
  - `DOM` 浏览器提供的方法，使得我们可以用JS获取或操作当前页面中的元素
  - `BOM` 浏览器提供的方法，是的我们可以使用JS操作浏览器对象

- Node是基于事件驱动的异步编程

## 课时129：在node环境中执行js代码

## 课时130：node中模块的基础知识

- 内置模块：http(createHttp..)、fs(writeFileSync、readFileSync)...
- 自定义模块
  - 在Node环境中，我们在当前的项目下创建一个JS文件，就相当于创建了一个模块，例如新建一个a.js，就相当于创建了a模块
  - 如果如要提供一些方法给其它的模块使用，则需要通过module.exports把方法打包后导出去
  - 如果现在在B模块中使用A模块，需要先导入`var a = require("./a")`，
然后就可以直接使用

- 第三方模块： 插件、别人写好的

## 课时131：node内置模块中常用的方法

## 课时132：静态资源文件请求的处理

> 竟然写mini_IIS，以前我拿C#就写过，再次温习。

- miniWebServer服务器原理：
  1. 拿到req.url，判断后缀格式，在响应头加`Content-Type`；
  2. try...catch方法fs读取文件，成功就返回，不成功就404
  3. 结束响应

- MIME类型：每一种资源文件都有自己的标识类型，浏览器会按照代码的MIME类型进行渲染
  - HTML文件标识为`text/html`
  - CSS文件标识为`text/css`
  - js文件标识为`text/javascript`
  - txt文件标识为`text/plain`
  - json文件标识为`application/json`
  

```javascript
// -> 处理静态资源文件的请求(html/css/txt/jpg...) ==> "前端路由"
var reg = /\.(HTML|JS|CSS|JSON|TXT|ICO)/i;
if (reg.test(pathname)) {
    // 注意这里利用正则捕获时，要的是小正则捕获的内容index->1
    var suffix = reg.exec(pathname)[1].toUpperCase();
    var suffixMIME = ''
    switch (suffix) {
        case 'HTML':
            suffixMIME = 'text/html';
            break;
        case 'CSS':
            suffixMIME = 'text/css';
            break;
        case 'JS':
            suffixMIME = 'text/javascript';
            break;
        case 'JSON':
            suffixMIME = 'application/json';
            break;
        default:
            suffixMIME = 'text/plain';
    }
}
```

## 课时133：http报文及谷歌控制台的使用

- HTTP报文：客户端传递给服务端的内容和服务端传递给客户端的内容都属于HTTP报文，其包括：
  - 起始行：请求起始行 相应起始行
  - 首部：请求首部 响应首部 通用首部(请求和响应首部都有的部分) 自定义首部
  - 主体：请求主体 响应主体

```bash
【General 通用首部】
Request URL:http://jerryshi.com/
Request Method:GET
Status Code:200 OK
Remote Address:47.92.154.146:80
Referrer Policy:no-referrer-when-downgrade

【Request Headers 请求首部】
GET / HTTP/1.1          -> [请求起始行] http method/请求地址/http版本号
Host: jerryshi.com
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4,zh-TW;q=0.2,ja;q=0.2,fr;q=0.2
Cookie: Hm_lvt_aa3b6b381538f5a8dc7f2901c79ffc58=1499445424,1499863460,1500105809,1500639939

【Response Headers 响应首部】
HTTP/1.1 200 OK     -> [响应起始行] http版本号、响应状态码、状态码的说明
Server: nginx
Date: Mon, 24 Jul 2017 14:45:21 GMT
Content-Type: text/html
Transfer-Encoding: chunked
Connection: keep-alive
Vary: Accept-Encoding
X-Powered-By: Hexo
Content-Encoding: gzip
```

- [Response] 响应主体 服务器传递给客户端的数据内容都在响应主体中，客户端可以在响应主体中获取这些内容（服务端配置 客户端获取）

- [Request Payload] 请求主体 客户端传递给服务端的数据内容可以放在请求主体中传递给服务端，服务端可以在请求主体中获取传递进来的内容

- 客户端传递给服务端数据方式：
  - 请求URL后面问号传参 `getList?name=jerry&age=18`
  - 设置请求的首部(设置请求头信息)
  - 设置请求主体
  
- 服务端给客服端传递数据方式
  - 设置响应头信息
  - 设置响应主体内容

----------

## 课时134：ajax基础知识

- Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）
 - 客户端JS中的方法，用来向服务端发送请求(还可以传递数据给服务端)，然后把服务端返回的内容获取到(Ajax一般是运行在客户端的浏览器中) 
- XML：可扩展的标记语言(在XML文件中使用标签都是自己扩展的)
  - 利用自己扩展的规则去标记来存储相关的数据 

```javascript
// Ajax使用一般分为四个步骤
// 1.实例化创建一个Ajax对象(此方法在IE6中不兼容)
var xhr = new XMLHttpRequest;

// 2.发送前的基本配置信息：
// 参数：http mdthod, 氢气地址, 是否异步, 用户名, 密码
xhr.open("get", "/data.txt", false, [username], [password]);

// 3.监听该对象状态改变行为
xhr.onreadystatuschange = function () {
    if (xhr.status === '200') {  }
}

// 4.发送ajax请求
xhr.send(null);
```

- xhr.status: HTTP网络状态码，描述了服务器响应内容的状态
  - `200` or /^2\d\d/ (200或200开头的) --> 都代表响应主体的内容已经成功返回
  - `301`  --> 永久重定向/永久转移 (eg:360buy -> jd)
  - `302`  --> 临时重定向/临时转移 (eg: 服务器的负载均衡)
  - `304`  --> 本次获取的内容是读取缓存中的数据
  - `400`  --> 客户端向服务端传参出现错误
  - `401`  --> 无权限访问
  - `404`  --> 访问的地址不存在
  - `500`  --> 未知的服务器错误
  - `503`  --> 服务器超负荷 (eg:某服务器能负载10000人，那么第10001人访问时，就会返回503)

- `xhr.send(null)` 其参数就是请求主体。在没send前都只是准备中
  
----------

## 课时135：ajax兼容处理及惰性思想

- JS高阶编程技巧之惰性思想：能够执行一次就搞定的绝对不会执行多次
  - 惰性思想 + 函数覆盖
  - 原理：仅判断一次，确认结果后直接将大函数指针改去小函数堆内存地址

```javascript
function createXHR() {
  var xhr = null,
    ary = [
      function () {
        return new XMLHttpRequest;
      },
      function () {
        return new ActiveXObject("Microsoft.XMLHTTP");
      },
      function () {
        return new ActiveXObject("Msxml2.XMLHTTP");
      },
      function () {
        return new ActiveXObject("Msxml3.XMLHTTP");
      }
    ];
  var i, len;
  for (i = 0, len = ary.length; i < len; i++) {
    try {
      xhr = ary[i]();  // 直接返回执行结果
      // 如果能运行到下面说明刚好能兼容
      // 既然能兼容就直接修改这个函数堆内存指向数组中兼容的函数
      createXHR = ary[i];
      break; //不能再循环了
    } catch (e) {
      console.log('Your bowser is not support ajax.');
    }
  }
  return xhr;
}
```

- 第一次运行返回小函数，第二次执行时返回对象。这个图截图时`xhr = ary[i]`，这样就能看去区别。因为第二次执行时，在第一次执行结果上`createXHR`变量指向的堆内存已经修改，所以第二次执行的返回的是一个对象。
![image.png-36.3kB][1]

- 还有一种单例模式 + 惰性思想的编程模式。这种模式是项目中最常见的，因为简单实用。

```javascript
(function () {
    var flag = 'getComputedStyle' in window;
    function getCss(curEle, name) {
        if (flag) {
            //
        }
    }
    return {
        getCss: getCss
    }
})()
```

----------

## 课时136：ajax中的http请求方式

- HTTP METHOD：客户端向服务端发送请求的方式
  - 以下的请求方式不管哪一种都可以向服务器传递数据，也可以从服务器获取到数据，而且从本质意义上讲，其实所有方式是没有任何区别的，例如用POST做的事情，用GET也能做。而我们讲的区别都是目前开发时约定俗成的规范
  - GET：一般用于从服务端获取数据(给服务端的数据少，从服务端取数据多，最常见)
  - PSOT：一般应用于向服务端推送数据(给服务端数据多，从服务端取数据少)
  - DELETE：一般用于从服务端上删除资源文件等
  - HEAD：一般应用于只获取服务端返回的响应报文头信息

- GET ~pk~ POST
  - 【大小问题】GET请求传递服务端的内容大小存在大小限制，而POST理论上没有限制。因为：GET通过URL传参给服务器，而每个浏览器对URL的长度存在限制，chrome~8kb，火狐7kb，IE~2kb的长度限制，浏览器会把超出的部分截取；
  - 【缓存问题】GET请求会出现缓存(不一定是304)，POST是没有缓存的。可以在get请求最后加一个请求参数，参数是随机数。

----------

## 课时137：ajax中的同步编程和异步编程

- JavaScript属于单线程的，我们最好都利用异步编程：
  - 定时器都是异步的
  - 事件绑定都是异步的
  - 回调函数也可以理解为异步的
  - Ajax中可以使用异步编程

```javascript
// ajax各种同步异步比较
// 第一种：异步的open在监听之前
var xhr1 = new XMLHttpRequest;
xhr1.open('GET', '/data.txt', true);    // -> 这里已经状态由0变1
xhr1.onreadystatechange = function () {
    console.log(xhr1.status);   // -> 故 2 3 4
}
xhr1.send(null);
/////////////////////////////////////////////////////////
// 第二种：异步的监听在open之前
var xhr2 = new XMLHttpRequest;
xhr2.onreadystatechange = function () { 
    console.log(xhr2.status);   // -> 1 2 3 4
} // 因为在状态改变前就将打印函数绑定上，所以就有上面结果
xhr2.open('GET', '/data.txt', true); 
xhr2.send(null);
/////////////////////////////////////////////////////////
// 第三种：同步的send在最后
var xhr3 = new XMLHttpRequest;
xhr3.open('GET', '/data.txt', false);  // -> 同步模式下直到状态到4才去修改status，则在监听时不需要判断状态，因为直接就是4了
xhr3.onreadystatechange = function () {
    console.log(xhr3.status);   // -> 故 4
}
xhr3.send(null);
/////////////////////////////////////////////////////////
// 第四种：同步的监听在sned之后
var xhr4 = new XMLHttpRequest;
xhr4.open('GET', '/data.txt', false);  // -> 同步模式下直到状态到4才去修改status
xhr4.send(null); // 而同步时会卡在这行，此时函数并没有绑定上去，所以什么都没有
xhr4.onreadystatechange = function () {
    console.log(xhr4.status);
}
```

- 关于ajax异步用head请求获取响应头(获取服务器时间...)。在例如小米商城的抢购业务中，基本上确定是用`head`请求获取服务器时间，因为head发挥请求一般在1~5ms，可以最好的解决网络速度方面存在的差异。

```javascript
var xhr5 = new XMLHttpRequest;
xhr5.open('HEAD', '/time', true);  
xhr5.onreadystatechange = function () {
    if (xhr5.readyState === 2) { // 此时ajax刚刚接收到响应头，里面包含服务器时间
        // 显示服务器时间
    }
}
xhr5.send(null);
```

----------

## 课时138：编写简易的ajax方法库

- 实现原理步骤：
  1. 闭包，仅暴露ajax方法，其形参为一对象`options`；
  2. 进来第一步先初始化`_default`对象；
  3. 然后再用options覆盖`_default`；
  4. 为url加随机参数，防止缓存
  5. 开启ajax
  6. 调用getHeader回调
  6. 处理dataType
  7. 调用success回调
  8. 完成

```javascript
(function () {
  function createXHR() {
    var xhr = null,
      ary = [
        function () {
          return new XMLHttpRequest;
        },
        function () {
          return new ActiveXObject("Microsoft.XMLHTTP");
        },
        function () {
          return new ActiveXObject("Msxml2.XMLHTTP");
        },
        function () {
          return new ActiveXObject("Msxml3.XMLHTTP");
        }
      ];
    var i, len;
    for (i = 0, len = ary.length; i < len; i++) {
      try {
        xhr = ary[i](); // 直接返回执行结果
        // 如果能运行到下面说明刚好能兼容
        // 既然能兼容就直接修改这个函数堆内存指向数组中兼容的函数
        createXHR = ary[i];
        break; //不能再循环了
      } catch (e) {
        console.log('Your bowser is not support ajax.');
      }
    }
    return xhr;
  }
  
  function ajax(options) {
    // 配置默认项
    var _default = {
      type: 'get',
      url: '',
      async: true,
      dataType: 'JSON',
      data: null,
      header: null,
      success: null
    };
    
    // options 覆盖 _default (以后都用_default)
    for (var key in _default) {
      // 只要非继承属性 && 只覆盖默认对象里有的属性
      if (_default.hasOwnProperty(key) && options[key]) {
        _default[key] = options[key];
      }
    }
    
    // 处理添加随机数杜绝缓存
    _default.url += _default.url.indexOf('?') >= 0 ? '&' : '?';
    _default.url += '_=' + Math.random();
    
    // 开始配置ajax对象
    var xhr = createXHR();
    xhr.open(_default.type, _default.url, _default.async);
    xhr.onreadystatechange = function () {
      if (/^2\d\d/.test(xhr.status)) {
        if (xhr.readyState === 2) {
          typeof _default.header === 'function' ? _default.header.call(xhr) : null;
        }
        if (xhr.readyState === 4) {
          var res = xhr.responseText;
          if (_default.dataType.toLocaleUpperCase() === 'JSON') {
            try { // 处理给JSON转一个普通字符串时的异常
              res = 'JSON' in window ? JSON.parse(res) : eval('(' + res +')');
            } catch (e) {
              console.error(e)
            }
          }
          typeof _default.success === 'function' ? _default.success.call(xhr, res) : null;
        }
      }
    };
    xhr.send(_default.data);
  }
  
  window.ajax = ajax;
})();
```

----------

## 课时139：项目开发流程和api接口文档

- API规范：
  1. 接口描述
  2. 地址url
  3. 参数
  4. 返回示例

----------

## 课时140：node创建服务发布项目

- 步骤：
  1. 写个静态资源web服务器
  2. 新建customer.json文件夹存储客户

----------

## 课时141：node编写获取所有客户信息

- 步骤：
  1. 判断pathname后读取json文件
  2. 判断读取的内容字符串是否为空，为空就空数组
  3. JSON转换成数组对象，写入result
  4. 根据结果返回result

----------

## 课时142：node编写获取指定用户信息

- 步骤：
  1. 把读取JSON文件和转换成对象放上层公共区域
  2. for循环数组返回结果

----------

## 课时143：node编写删除指定客户信息

- 步骤：
  1. 转换query成对象
  2. 循环对象，删除结果
  2. 如果有对象有删除，就写入文件
  3. 没有删除就返回失败

## 课时144：node编写增加客户信息

- 步骤：
  1. 因为是post，且因为node是异步和基于事件驱动
  2. 所以我们用`req.on('data', function (chunk) { res += res;})`来获取post的data数据
  3. 然后写入json文件

----------

## 课时145：node编写修改客户信息

> 和添加一样。

----------

## 课时146：实现基本的布局结构

- index.css
 1. 写html骨架，表头用h2+span*6写；
 2. 表体用li+span*6表示，好了，html标签写完，写css；
 3. css，首先清除默认margin、padding，清除a标签默认样式；
 3. box类默认800px 价格边框；
 4. add类因为是在a标签上，可以加hover伪类；
 5. head类因为都是字，可以用`line-height`让文垂直字垂直居中；
 6. head类下的span改为向左浮动，text-align居中左右居中，`line-height`垂直居中。因为家了浮动，才可以设置大小后让元素在一个行内移动，修改float后其实元素也变为行内元素了；
 7. ul下的li样式可以合并到head类里的span里；
 8. 用nth-child做li的隔行换色`#eee`；
 9. 让control下的a标签为`inline-block`，并修改其hover伪类；

----------

## 课时147：绑定所有的客户信息


----------

## 课时148：增加客户信息


----------

## 课时149：修改客户信息


----------

## 课时150：删除客户信息


----------



  [1]: http://static.zybuluo.com/szy0syz/tdh2gnb4g9laeyotoj18buqo/image.png
  