# 珠峰前端全栈培训第七周：ajax jsonp node基础及项目实战开发

[TOC]

## 课时125：常用的dos命令

> 我接触Windows系统快19年、系统维护超过6年，基本不需要扫盲了，但还是简单记录下~

- `ipconfig`、`ipconfig -all`
- `ping`
- `ctrl + c`
- `exit`
- `cls` 清屏
- `cd ../` 返回上一级目录、`cd ./` 当前目录、`cd /` 返回当前磁盘根目录
- `e:` 直接进入E盘
- `cd dirname`
- `dir`

## 课时126：客户端和服务器端的交互模式

- W3C
一个指定开发规范的非盈利性组织 HTML/HTML5/CSS/CSS3/ECMAScript...的规范都是由这个组织制定和管理的。
我们作为一个开发者开发的页面，也是按照规范来开发的
浏览器开发商一般也是按照W3C的规范开发浏览器的引擎
但是浏览器厂商总要凸显自己的与众不同，有些厂商把W3C规范实现后，又增加了一些自己独有的好东西(谷歌)，这就导致了我们在写代码的时候经常写：`-webkit-xxxx:xxx`
但是又有些厂商，为了凸显自己的不一样，就是不按照规范来，而走自己的一套(IE)，这也就导致编写的代码想要兼容所有浏览器就需要写多套代码：如chrome的`getComputedStyle`、IE为`currentStyle`

- 通过在Chrome的Network中观看，我们发现当第一次把html源代码请求回来时，浏览器开始按照自己的引擎渲染，在渲染过程中我们还会出现重新向服务器请求CSS、JS、IMG....，每次的请求步骤和HTML的步骤是一样的；如果请求资源次数太多，页面打开的速度和渲染的速度就会变慢，所以我们以后在页面优化的方法中，首先要做的就是减少资源请求数(减少HTTP请求)
  - CSS合并成一个 或者 CSS不是很多的话我们采用内联样式
  - JS合并成一个 或者采用内联式
  - 图片合并(雪碧图技术/CSS Sprite) 或者 图片延迟加载
  - Ajax请求和资源文件的请求原理也是一样


## 课时127：url和http基础知识

- URI、URL、URN

URI = URL + URN (统一资源标识符/统一资源信息)

URL：统一资源定位符
`https://v.qq.com/index.html?name=jerry&age=18#target`
`#target`：URL的hash(锚点定位) 

## 课时128：初步了解node

- JS是一门“运行在客服端(即浏览器)”的“轻量级”的脚本编程语言

- Node是一个环境，供JS代码执行的环境，我们可以把它等价于浏览器，只不过我们一般都会把Node这个环境安装到服务端，这样的话我们就可以在服务器端使用JS编写程序了，也就是说JS不仅仅是客户端语言也是服务端语言

- Node采用的是谷歌V8引擎渲染JS（运行速度快、稳定、不需要考虑兼容）
- 浏览器中的全局JS对象是window，而Node环境下的全局JS对象是Global
- 浏览器是安装在客户端的，为了保护客户端的安全，基本上不可能提供用JS对客户端电脑磁盘上的文件进行操作的功能；但Node环境中提供了对应的I/O操作，我们使用JS可以对服务器上的磁盘文件进行操作。

- JavaScript分为三部分：ECMAScript、DOM、BOM
  - `JavaScript` 实现了ECMAScript的语法规范
  - `DOM` 浏览器提供的方法，使得我们可以用JS获取或操作当前页面中的元素
  - `BOM` 浏览器提供的方法，是的我们可以使用JS操作浏览器对象

- Node是基于事件驱动的异步编程

## 课时129：在node环境中执行js代码

## 课时130：node中模块的基础知识

- 内置模块：http(createHttp..)、fs(writeFileSync、readFileSync)...
- 自定义模块
  - 在Node环境中，我们在当前的项目下创建一个JS文件，就相当于创建了一个模块，例如新建一个a.js，就相当于创建了a模块
  - 如果如要提供一些方法给其它的模块使用，则需要通过module.exports把方法打包后导出去
  - 如果现在在B模块中使用A模块，需要先导入`var a = require("./a")`，
然后就可以直接使用

- 第三方模块： 插件、别人写好的

## 课时131：node内置模块中常用的方法

## 课时132：静态资源文件请求的处理

> 竟然写mini_IIS，以前我拿C#就写过，再次温习。

- miniWebServer服务器原理：
  1. 拿到req.url，判断后缀格式，在响应头加`Content-Type`；
  2. try...catch方法fs读取文件，成功就返回，不成功就404
  3. 结束响应

- MIME类型：每一种资源文件都有自己的标识类型，浏览器会按照代码的MIME类型进行渲染
  - HTML文件标识为`text/html`
  - CSS文件标识为`text/css`
  - js文件标识为`text/javascript`
  - txt文件标识为`text/plain`
  - json文件标识为`application/json`
  

```javascript
// -> 处理静态资源文件的请求(html/css/txt/jpg...) ==> "前端路由"
var reg = /\.(HTML|JS|CSS|JSON|TXT|ICO)/i;
if (reg.test(pathname)) {
    // 注意这里利用正则捕获时，要的是小正则捕获的内容index->1
    var suffix = reg.exec(pathname)[1].toUpperCase();
    var suffixMIME = ''
    switch (suffix) {
        case 'HTML':
            suffixMIME = 'text/html';
            break;
        case 'CSS':
            suffixMIME = 'text/css';
            break;
        case 'JS':
            suffixMIME = 'text/javascript';
            break;
        case 'JSON':
            suffixMIME = 'application/json';
            break;
        default:
            suffixMIME = 'text/plain';
    }
}
```

## 课时133：http报文及谷歌控制台的使用

- HTTP报文：客户端传递给服务端的内容和服务端传递给客户端的内容都属于HTTP报文，其包括：
  - 起始行：请求起始行 相应起始行
  - 首部：请求首部 响应首部 通用首部(请求和响应首部都有的部分) 自定义首部
  - 主体：请求主体 响应主体

```bash
【General 通用首部】
Request URL:http://jerryshi.com/
Request Method:GET
Status Code:200 OK
Remote Address:47.92.154.146:80
Referrer Policy:no-referrer-when-downgrade

【Request Headers 请求首部】
GET / HTTP/1.1          -> [请求起始行] http method/请求地址/http版本号
Host: jerryshi.com
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4,zh-TW;q=0.2,ja;q=0.2,fr;q=0.2
Cookie: Hm_lvt_aa3b6b381538f5a8dc7f2901c79ffc58=1499445424,1499863460,1500105809,1500639939

【Response Headers 响应首部】
HTTP/1.1 200 OK     -> [响应起始行] http版本号、响应状态码、状态码的说明
Server: nginx
Date: Mon, 24 Jul 2017 14:45:21 GMT
Content-Type: text/html
Transfer-Encoding: chunked
Connection: keep-alive
Vary: Accept-Encoding
X-Powered-By: Hexo
Content-Encoding: gzip
```

- [Response] 响应主体 服务器传递给客户端的数据内容都在响应主体中，客户端可以在响应主体中获取这些内容（服务端配置 客户端获取）

- [Request Payload] 请求主体 客户端传递给服务端的数据内容可以放在请求主体中传递给服务端，服务端可以在请求主体中获取传递进来的内容

- 客户端传递给服务端数据方式：
  - 请求URL后面问号传参 `getList?name=jerry&age=18`
  - 设置请求的首部(设置请求头信息)
  - 设置请求主体
  
- 服务端给客服端传递数据方式
  - 设置响应头信息
  - 设置响应主体内容

----------

## 课时134：ajax基础知识

- Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）
 - 客户端JS中的方法，用来向服务端发送请求(还可以传递数据给服务端)，然后把服务端返回的内容获取到(Ajax一般是运行在客户端的浏览器中) 
- XML：可扩展的标记语言(在XML文件中使用标签都是自己扩展的)
  - 利用自己扩展的规则去标记来存储相关的数据 

```javascript
//


// -> xhr.status: HTTP网络状态码，描述了服务器响应内容的状态

```

- xhr.status: HTTP网络状态码，描述了服务器响应内容的状态
  - 200 or /^2\d\d/ (200或200开头的) --> 都代表响应主体的内容已经成功返回
  - `301`  --> 永久重定向/永久转移
  - `302`  --> 临时重定向/临时转移
  - `304`  --> 本次获取的内容是读取缓存中的数据
  - `400`  --> 客户端向服务端传参出现错误
  - `401`  --> 无权限访问
  - `404`  --> 访问的地址不存在


