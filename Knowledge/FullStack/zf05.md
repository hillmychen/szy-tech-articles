[TOC]

----------

## 课时104：什么是事件

- 什么是事件?
  1. 行为本身：浏览器天生就赋予其的行为，例如`onclick`, `onmouseover(onmouseenter)`, `onmouseout(onmouseleave)`, `onmousemove`, `onmousedown`, `onmouseup`, `onmousewheel`(鼠标滚轮滚动行为), `onscroll`
  2. 事件绑定：给元素的某一个行为绑定方法
 

```javascript
var oDiv = document.getElementById("#box");

// onclick这个行为定义在当前元素的私有属性上
// 我们称之为DOM 0级事件绑定
oDiv.onclick = function handler () { ... };

// addEventListener这个属性则定义在"EventTarget"这个接口上，放在该元素的原型链上
// 我们称之为DOM 2级事件绑定
oDiv.addEventListener("click", handler);
```

- 关于为什么没有DOM 1级事件： 很久以前，DOM刚开发时，版本为0级，后来又进行了一次升级升级到1级，但这次升级并没有更新DOM事件，后来再次升级到DOM 2级时，DOM事件得到了更新就有了DOM2级事件绑定。


----------

## 课时105：事件对象及兼容处理

```javascript
// 表示我们把匿名函数定义的部分当做一个值赋值给了oDiv的点击行为(函数表达式)
oDiv.onclick = function (mouseEvent) { ... }
// 当我们触发#div的点击行为时，会执行对应绑定上的方法
// ★重要：不仅仅把绑定的方法执行了，而且浏览器还默认的给这个方法传递了一个参数 --> MouseEvent：鼠标事件对象
//   1. 它是一个对象数据类型值，里面包含了很多属性名和属性值，这些都是用来记录当前鼠标的相关信息
//   2. MouseEvent的原型链：MouseEvent -> UIEvent -> Event -> Object
//   3. MouseEvent记录的是页面中唯一一个鼠标每次触发时的相关信息，和到底是在哪个元素上触发的没关系
```

**关于事件对象MouseEvent的兼容问题**
```javascript
oDiv.onclick = function (e) {
  // 在非标准浏览器(IE6~8)中，我们需要去window.event上获取。
  e = e || window.event;
  e.target = e.target || e.srcElement
  e.pageX = e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft)
  e.pageY = e.clientY + (document.documentElement.scrollTop || document.body.scrollTop)
  e.preventDefault ? e.preventDefault() : e.returnValue=false
  // 阻止默认行为可以直接用return false！
  // 更可以在html事件代码中直接加"javascript:;"或者"javascript: void 0;"或者"javascript: viod 1;"
  
  // e.stopPropagation 阻止事件的冒泡传播，在IE6~8中不兼容，使用e.cancelBubble=true兼容处理
  e.stopPropagation ? e.stopPropagation() : e.cancelBubble=true
}
  // e.type：当前鼠标触发的行为类型 “click” ...
  // e.clientX/e.clientY：当前鼠标触发点所距离当前浏览器屏幕(viewport,视口)左上角的x轴和y轴的坐标值
  // e.target：事件源，当前鼠标触发的是哪个元素
  // e.pageX/e.pageY：当前鼠标触发点所距离body左上角的x/y轴的坐标，但问题是在IE6~8下不兼容，处理办法为使用clientX/Y+滚动条卷曲的高度或宽度即可
  // e.preventDefault: 阻止浏览器的默认行为，但问题是IE6~8中不兼容，使用e.returnValue=false解决兼容问题
  
  // KeyboardEvent 键盘事件对象
  // e.keyCode：当前键盘上每一个键对应的值
  // 空格键(space)->32 , 退回键(Backspace)->8 , 回车键(Enter)->13 , 删除键(Del)->46
```

----------

## 课时106：事件的传播机制

- 事件的默认传播机制：
  - 捕获阶段：从外向内依次查找元素
  - 目标阶段：当前事件源本身的操作
  - 冒泡阶段：从内到外依次触发相关的行为
  
- 使用DOM-0级事件给元素的某一个行为绑定的方法，都是在行为触发后的冒泡阶段才去执行方法

- 因为由捕获阶段或冒泡阶段或目标阶段触发是的事件对象全都是相等的


----------

## 课时107：案例之鼠标跟随(jQuery版)

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson107</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        .box {
            position: relative;
            width: 598px; /*图片140*4=560 左右边框2*4 margin-right:10*3 = 598 + 最后一个无用的margin-right=608 */
            height: 98px; /*上下边框2 图片75 margin-top:10 margin-bottom:10 = 98*/
            margin: 50px auto;
            border: 1px dashed darkgray;
        }

        .box .content {
            position: absolute;
            /*width: 100%;*/ /*千万别设100%，自适应，弟弟可以超过哥哥*/
            /*height: 100%;*/
            margin-right: -20px; /*哇哈哈~负边距应用了，成功放大了content元素！*/
            overflow: hidden;
        }

        .box img { /* 140*75 */
            float: left;
            margin: 10px 10px 10px 0;
            border: 1px solid red;
        }

        .mask {
            display: none;
            position: absolute;
            left: 0;
            top: 0;
            width: 522px; /*原始图片为520*280，但我上下和左右分别加了边框，所以各加2*/
            height: 282px;
            border: 1px solid lightgray;
            background: no-repeat center center;
        }
    </style>
</head>
<body>
<div id="box" class="box">
    <div id="content" class="content">
        <img src="./imgs/i01s.jpg" bigsrc="./imgs/i01.jpg" alt="1">
        <img src="./imgs/i02s.jpg" bigsrc="./imgs/i02.jpg" alt="2">
        <img src="./imgs/i03s.jpg" bigsrc="./imgs/i03.jpg" alt="3">
        <img src="./imgs/i04s.jpg" bigsrc="./imgs/i04.jpg" alt="4">
    </div>
    <div class="mask" id="mask"></div>
</div>
<script src="../jquery-1.12.4.js" type="text/javascript"></script>
<script type="text/javascript">
  $(function () {
    var boxOffet = $('#box').offset(),
        $imgs = $('img'),
        $mask = $('#mask');

    $imgs.mouseenter(function (e) {
      $mask
        .css("background-image", 'url("' + this.getAttribute("bigsrc") + '")')
        .finish()
        .fadeIn(400)
        .css({ //这里不能拿img的offset设置啊，因为mask是根据box定位，所以拿box的offset绝对距离即可！
          left: e.clientX - boxOffet.left + 10,
          top: e.clientY - boxOffet.top + 10
        });
    });

    $imgs.mouseleave(function (e) {
      $mask
        .finish()
        .fadeOut(200);
    });

    $imgs.mousemove(function (e) {
      $mask
        .css({
          left: e.clientX - boxOffet.left + 10,
          top: e.clientY - boxOffet.top + 10
        });
    });
  })
</script>
</body>
</html>
```

> 自己坑自己啊，写项目时头脑要清晰！昨晚儿子搞事情，05点才睡着，也是没法😣
  当然也玩了个负边距“放大”布局!!好玩!!

- 项目里mask是根据box定位的，所以在计算其top和left时，因用`e.clientX - box.offset().left + 10px`，而不能是`e.clientX - $(this).offset().left + 10`。

![zf-lesson107.png-35.4kB][1]

----------

## 课时108：案例之鼠标跟随(原生js版)

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson108_VanillaJS</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        .container {
            position: relative;
            height: 402px;
            width: 402px;
            margin: 100px auto;
            border: 2px dashed red;
            background: lightgray;
        }

        .container .box {
            display: none;
            position: absolute;
            background: green;
            height: 100px;
            width: 100px;
            top: 410px;
            left: 410px;
        }
    </style>
</head>
<body>
<!--挖坑第一步：故意把box放在容器里，增加难度，为了理解时间的传播机制。-->
<div id="container" class="container">
    <div class="box" id="box"></div>
</div>
<script type="text/javascript">
  var cta = document.getElementById("container"),
    box = document.getElementById("box");
  //挖坑第二步，使用mouseover和mouseout事件触发行为
  //    cta.addEventListener('mouseover', function (e) {
  //      e = e || window.event;
  //      e.target = e.target || e.srcElement;
  //      box.style.display = 'block';
  //      box.style.left = e.clientX - cta.offsetLeft + 6 + 'px';
  //      box.style.top = e.clientY - cta.offsetTop + 10 + 'px';
  //    }, false);
  //
  //    cta.addEventListener('mousemove', function (e) {
  //      e = e || window.event;
  //      e.target = e.target || e.srcElement;
  //      box.style.left = e.clientX - cta.offsetLeft + 6 + 'px';
  //      box.style.top = e.clientY - cta.offsetTop + 10 + 'px';
  //    }, false);
  //
  //    cta.addEventListener('mouseout', function () {
  //      box.style.display = 'none';
  //    }, false);
  
  // 为什么我没遇到周老师讲的坑呢，奇怪啊，各种办法都试了。
  // 我明白了，原来他用的是事件函数里用的是"this"，如果那就复杂了。
  // 如果你this是container还好，如果是box那就冒泡了。
  //  cta.onmouseover = function (e) {
  //    e = e || window.event;
  //    e.target = e.target || e.srcElement;
  //    box.style.display = 'block';
  //    box.style.left = e.clientX - cta.offsetLeft + 6 + 'px';
  //    box.style.top = e.clientY - cta.offsetTop + 10 + 'px';
  //  };
  //
  //  cta.onmousemove = function (e) {
  //    e = e || window.event;
  //    e.target = e.target || e.srcElement;
  //    box.style.left = e.clientX - cta.offsetLeft + 6 + 'px';
  //    box.style.top = e.clientY - cta.offsetTop + 10 + 'px';
  //  };
  //
  //  cta.onmouseout = function (e) {
  //    box.style.display = 'none';
  //  }
  
  // 我承认，我试了三遍，硬是没把坑试出来，是不是我基础太好了啊~~
  //  cta.onmouseover = function (e) {
  //    e = e || window.event;
  //    e.target = e.target || e.srcElement;
  //    box.style.display = 'block';
  //    box.style.left = e.clientX - this.offsetLeft + 6 + 'px';
  //    box.style.top = e.clientY - this.offsetTop + 10 + 'px';
  //  };// 这尼玛永远也是container啊，不会出来周老师的坑嘛，哎，找个坑跳也那么麻烦，罢了。
  //
  //  cta.onmousemove = function (e) {
  //    console.dir(this);
  //    e = e || window.event;
  //    e.target = e.target || e.srcElement;
  //    box.style.left = e.clientX - this.offsetLeft + 6 + 'px';
  //    box.style.top = e.clientY - this.offsetTop + 10 + 'px';
  //  };
  //
  //  cta.onmouseout = function (e) {
  //    box.style.display = 'none';
  //  }
  
  // 第四遍，使用mouseenter和mouseleave代替，应为这两货在MDN文档中严重标明不支持冒泡机制！欧耶~
  cta.onmouseover = function (e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    box.style.display = 'block';
    box.style.left = e.clientX - this.offsetLeft + 6 + 'px';
    box.style.top = e.clientY - this.offsetTop + 10 + 'px';
  };// 这尼玛永远也是container啊，不会出来周老师的坑嘛，哎，找个坑跳也那么麻烦，罢了。
  
  cta.onmousemove = function (e) {
    console.dir(this);
    e = e || window.event;
    e.target = e.target || e.srcElement;
    box.style.left = e.clientX - this.offsetLeft + 6 + 'px';
    box.style.top = e.clientY - this.offsetTop + 10 + 'px';
  };
  
  cta.onmouseout = function (e) {
    box.style.display = 'none';
  }
</script>
</body>
</html>
```

> 我输了，试了四遍，硬是没找到坑跳进去啊😂

- `mouseenter`和`mouseover` 、`mouseleave`和`mouseout`的本质区别：`mouseenter`和`mouseleave`这两个事件都是阻止事件冒泡，而`mouseover`和`mouseout`则不阻止事件冒泡。阻止行为冒泡传播的好处在于当触发子元素的某个行为时，导致父元素的该行为也被触发。

----------

## 课时109：鼠标跟随 深入理解事件的传播机制

```javascript
<script type="text/javascript">
  var box = document.getElementById("box"),
    inner = document.getElementById("inner");

  //    box.onmouseover = function () {
  //      inner.style.display = "block";
  //    };
  //
  //    box.onmouseout = function () {
  //      inner.style.display = "none";
  //    };

  // 升级绑定行为，取消事件的冒泡传递！
  box.onmouseenter = function () {
    inner.style.display = "block";
  }

  box.onmouseleave = function () {
    inner.style.display = "none";
  }
</script>
```

> 使用地球最快的Vanilla.js框架实现lesson107效果

```javascript
<script type="text/javascript">
  var cta = document.getElementById('container'),
    box = document.getElementById('box'),
    mask = document.getElementById('mask'),
    imgList = box.getElementsByTagName('img');
  // box距离body的距离，中间包了个container，手工算吧。
  // 算了都是根据container定位，不许算两道了，没意思。
  var ctaOffsetLeft = cta.offsetLeft,
    ctaOffsetTop = cta.offsetTop;

  function handleMouseEnter(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    mask.style.backgroundImage = 'url("' + this.getAttribute("bigsrc") + '")';
    mask.style.display = 'block';
    mask.style.left = e.clientX - ctaOffsetLeft + 10 + 'px';
    mask.style.top = e.clientY - ctaOffsetTop + 10 + 'px';
  }

  function handleMousemove(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    mask.style.left = e.clientX - ctaOffsetLeft + 10 + 'px';
    mask.style.top = e.clientY - ctaOffsetTop + 10 + 'px';
  }

  function handleMouseLeave() {
    mask.style.display = 'none';
  }

  for (var i = 0, len = imgList.length; i < len; i++) {
    // 其实这里可以用捕获来优化，直接绑定在box上即可，第二版本再优化。
    imgList[i].addEventListener('mouseenter', handleMouseEnter, false);
    imgList[i].addEventListener('mousemove', handleMousemove, false);
    imgList[i].addEventListener('mouseleave', handleMouseLeave, false);
  }
</script>
```

----------

## 课时110：事件委托 事件代理

- 什么叫事件委托/事件代理？利用事件的冒泡传播机制（触发当前元素的某项行为，它爸爸爷爷祖宗十八代元素的相关行为都会被触发）；如果一个容器里有很多元素都要绑定点击事件，我们没必要每一个都逐一绑定，只需给最外层的的容器绑定一个点击事件即可，在这个方法执行时，通过事件源来区分进行不同操作。

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson110</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        .container {
            position: relative;
            height: 33px;
            width: 100px;
            border: 1px solid #000000;
            margin: 50px auto;
        }

        .container .cart {
            /*position: absolute; 不必定位，定位了还不好居中*/
            height: 33px;
            line-height: 30px;
            text-align: center;
            background: lightblue;
        }

        .container .cartDetail {
            position: absolute;
            top: 33px;
            left: -1px;
            height: 200px;
            width: 200px;
            background: lightgray;
            border: 1px solid #000000;
            text-align: center;
            line-height: 66px;
        }
    </style>
</head>
<body>
<div id="container" class="container">
    <div class="cart" id="cart">
        <span>购物车</span>
        <div class="cartDetail" id="cartDetail" style="display: none">
            1. iPhone7<br/>
            2. Mi6<br/>
            3. P10<br/>
        </div>
    </div>
</div>

<script type="text/javascript">
  var ctnr = document.getElementById("container"),
    cart = document.getElementById("cart"),
    cartDetail = document.getElementById("cartDetail");

  function handleCartClick(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    if (e.target.id === 'cart' || (e.target.tagName.toLocaleLowerCase() === 'span' && e.target.parentNode === cart)) {
      var dsp = cartDetail.style.display;
      dsp === 'none' ? cartDetail.style.display = 'block' : cartDetail.style.display = 'none';
      return false;
    }
    if (e.target.id === 'cartDetail') {
      return false;
    }
    cartDetail.style.display = 'none';
  }
  // 将点击事件绑定在body上，实现事件委托或事件代理。
  document.body.addEventListener('click', handleCartClick, false);
</script>
</body>
</html>
```

----------

## 课时111：案例之京东商城放大镜

> 预先估计，和上面跟随差不多，但额外使用了div然后`backgroundImage: position `定位局部图

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson111</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        .box {
            position: absolute;
            width: 450px;
            height: 450px;
            top: 25px;
            left: 50px;
            border: none;
            box-shadow: 3px 3px 10px 0 #111111;
        }

        .box .mark {
            position: absolute;
            top: 0;
            left: 0;
            height: 300px;
            width: 300px;;
            display: block;
            border: 1px solid #aaa;
            background: #fede4f;
            opacity: 0.5;
            filter: alpha(opacity=50);
            z-index: 9;
            cursor: move;
        }

        .box img {
            display: block;
            border: none;
        }

        .box .imgDetail {
            position: absolute;
            top: 0;
            left: 458px;
            height: 540px;
            width: 540px;
            background: url("imgs/iPhone7plus_red_lg.jpg") no-repeat center center;
            background-position: 0 0;
            border: 1px dashed #aaaaaa;
        }
    </style>
</head>
<body>
<div id="box" class="box">
    <img src="imgs/iPhone7plus_red_sm.jpg" alt="iPhone7Plus" id="simg">
    <div class="mark" id="mark"></div>
    <div class="imgDetail" id="imgDetail" style="display: none"></div>
</div>

<script type="text/javascript">
  var box = document.getElementById('box'),
    mark = document.getElementById('mark'),
    imgDetail = document.getElementById('imgDetail');


  function setPoistion(e) {
    // 展示盒子 450px * 450px
    // 放大镜   300px * 300px
    // 明细盒子 540px * 540px
    var left = e.clientX - box.offsetLeft - (mark.offsetWidth / 2),
      top = e.clientY - box.offsetTop - (mark.offsetHeight / 2);
    var minLeft = 0, minTop = 0, maxLeft = box.offsetWidth - mark.offsetWidth,
      maxTop = box.offsetHeight - mark.offsetHeight;
    // 进行边界判断
    if (left > maxLeft) {
      left = maxLeft;
      mark.style.left = maxLeft + 'px';
    } else if (left <= minLeft) {
      left = minLeft;
      mark.style.left = minLeft + 'px';
    } else {
      mark.style.left = left + 'px';
    }
    // 进行边界判断
    if (top > maxTop) {
      top = maxTop;
      mark.style.top = maxTop + 'px';
    } else if (top <= minTop) {
      top = minTop;
      mark.style.top = minTop + 'px';
    } else {
      mark.style.top = top + 'px';
    }
    // 设置放大图的div里的backgroundPosition
    setDetailPosition(left, top);
  }

  function setDetailPosition(l, t) { // 2.6500
    l = -l * 1.77;
    t = -t * 1.77;
    // 这里又要有边界
    //你真别问我边界怎么算出来的，我也不知道，我是拿截图工具量出来的！
    var minL = -259,
      minT = -259;
    l < minL ? l = minL : null;
    t < minT ? t = minL : null;
    imgDetail.style.backgroundPosition = l + 'px ' + t + 'px';
  }

  function handleMouseEnter(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    console.dir(e.target);
    if (e.target.id === 'box') {
      imgDetail.style.display = 'block';
    }
    setPoistion(e);
  }

  function handleMouseLeave(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    if (e.target.id === 'box') {
      imgDetail.style.display = 'none';
    }
  }

  function handleMouseMove(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    e.clientX > box.offsetLeft + box.offsetWidth ? imgDetail.style.display = 'none' : null;
    e.clientY > box.offsetTop + box.offsetHeight ? imgDetail.style.display = 'none' : null;
    setPoistion(e);
  }

  box.addEventListener('mouseenter', handleMouseEnter);
  box.addEventListener('mouseleave', handleMouseLeave);
  box.addEventListener('mousemove', handleMouseMove);
</script>
</body>
</html>
```

----------

## 课时112：案例之百度搜索框

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson112</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            font-size: 14px;
        }

        /*这里如果不指定body的宽高，则它也是个盒子，也是撑不开，导致你就算上了onclick事件也不能触发，因为没宽度啊。*/
        html, body {
            width: 100%;
            height: 100%;
        }

        input {
            display: block;
            outline: none;
        }

        ul, li {
            list-style: none;
        }

        li a {
            display: block;
            text-decoration: none;
            color: #000000;
        }

        li a:hover a:target a:visited a:active {
            text-decoration: none;
            color: #000000;
        }

        .box {
            position: absolute;
            width: 400px;
            top: 20px;
            left: 50%;
            margin-left: -200px;
        }

        .box input {
            padding: 0 10px;
            width: 300px;
            height: 35px;
            margin-bottom: -1px; /*把底下的元素往上吸一个像素*/
            border: 1px solid #008000;
        }

        .box ul {
            display: none;
            position: relative;
            border: 1px solid #008000;
        }

        .box ul li, .box ul li a {
            height: 30px;
            line-height: 30px; /*文字垂直居中*/
        }

        .box ul li a {
            padding: 0 5px;
        }

        .box ul li a:hover {
            background: #cccccc;
        }
    </style>
</head>
<body>

<div id="box" class="box">
    <input type="text" id="searchInp" placeholder="wrods...">
    <ul id="searchList">
        <li><a href="javascript:;">《JavaScript权威指南(第六版)》</a></li>
        <li><a href="javascript:;">《你不知道的JavaScript》</a></li>
        <li><a href="javascript:;">《Node.js实战》</a></li>
        <li><a href="javascript:;">《深入浅出Nodejs》</a></li>
        <li><a href="javascript:;">《JavaScript高级编程(第三版)》</a></li>
    </ul>
</div>

<script type="text/javascript">
  //显示: 1.文本框获取焦点，并且文本框中有内容的时候；2.在文本框中操作(新输入、删除)内容，如果没有清空就显示，否则隐藏；
  //隐藏：1.点击页面其余的位置都隐藏(除了文本框和searchList里面的每一行)都隐藏；2.点击searchList隐藏，但还需要把列表中的内容放到文本框中；

  var searchInp = document.getElementById('searchInp'),
    searchList = document.getElementById('searchList');
  // 不管是获取焦点onfouces，还是在里面编辑内容onkeyup
  searchInp.onfocus = searchInp.onkeyup = function (e) {
    // String.trim();
    var val = this.value.replace(/(^ +| +$)/g, '');
    searchList.style.display = val.length > 0 ? 'block' : 'none';
  };

  function handleSearchList(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    // 如果点击的事件源是searchList下的a
    if (e.target.tagName.toLocaleLowerCase() === 'a' && (e.target.parentNode.parentNode === searchList)) {
      searchInp.value = e.target.childNodes[0].nodeValue;
      searchList.style.display = 'none';
      return;
    }
    // 如果点击的是搜索框，因为存在事件冒泡传播，会从body的click行为上捕获到搜索框再传冒泡到body。则我们不需要触发body的click行为，我们直接跳过。
    //也可以使用手工取消冒泡传播
    //if (e.target === searchInp) {
    //  return;
    //}
    //出停止搜索框的冒泡，这里就有问题。
    searchList.style.display = 'none';
  }

  // 也可以手工在搜索框的click上处理取消冒泡传播
  searchInp.onclick = function (e) {
    e = e || e.event;
    //终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。兼容IE~~
    e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;
  };

  //document.body.onclick = handleSearchList;
  document.body.addEventListener('click', handleSearchList);
</script>
</body>
</html>
```

----------

## 课时113：案例之多级菜单js版

- CSS技巧：渐进增强。首先设置一个纯色的背景，对于不兼容CSS3的浏览器的话就用纯色；对于兼容的浏览器的话，我们再下面再额外重复增加一个背景渐变色，这样就会把纯色的背景覆盖。

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson113</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            font-size: 14px;
            -webkit-user-select: none;
            user-select: none;
        }

        ul, li {
            list-style: none;
        }

        .box {
            margin: 10px;
            padding: 10px;
            width: 300px;
            border: 1px dashed #000000;
            /*渐进增强：首先设置一个纯色的背景，对于不兼容CSS3的浏览器的话就用纯色；对于兼容的浏览器的话，我们再下面再额外重复增加一个背景渐变色，这样就会把纯色的背景覆盖。*/
            background: #fede4f; /*PC端兼容css3样式，分别对应webkit、火狐、opera、ie*/
            background: -webkit-linear-gradient(to bottom, red 0%, blue 100%);
            background: -moz-linear-gradient(to bottom, red 0%, blue 100%);
            background: -o-linear-gradient(to bottom, red 0%, blue 100%);
            background: -ms-linear-gradient(to bottom, red 0%, blue 100%);
            background: linear-gradient(to bottom, red 0%, blue 100%);
        }

        .box li {
            position: relative;
            line-height: 30px;
        }

        .box em {
            position: absolute;
            top: 7px;
            left: 0;
            width: 16px;
            height: 16px;
            cursor: pointer;
            background: url("imgs/icon.png") no-repeat -59px -28px;
        }

        .box em.open {
            background-position: -42px -28px;
        }

        .box span {
            display: block;
            padding-left: 20px;
        }

        .box .levelTwo {
            margin-left: 20px;
        }

        .box .levelThree {
            margin-left: 20px;
        }

        .box .levelFour {
            margin-left: 20px;
        }

        .box .levelTwo, .box .levelThree, .box .levelFour {
            display: none;
        }

    </style>
</head>
<body>
<div class="box" id="box">
    <ul>
        <li>
            <em></em><span>第一级第一个</span>
            <ul class="levelTwo">
                <li><span>第二级第一个</span></li>
                <li>
                    <em></em><span>第二级第二个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                        <li>
                            <em></em><span>第三级第三个</span>
                            <ul class="levelFour">
                                <li><span>第四级第一个</span></li>
                                <li><span>第四级第二个</span></li>
                                <li><span>第四级第三个</span></li>
                            </ul>
                        </li>

                    </ul>
                </li>

                <li>
                    <em></em><span>第二级第三个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                    </ul>
                </li>

            </ul>
        </li>
        <li>
            <em></em><span>第一级第一个</span>
            <ul class="levelTwo">
                <li><span>第二级第一个</span></li>
                <li>
                    <em></em><span>第二级第二个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                        <li>
                            <em></em><span>第三级第三个</span>
                            <ul class="levelFour">
                                <li><span>第四级第一个</span></li>
                                <li><span>第四级第二个</span></li>
                                <li><span>第四级第三个</span></li>
                            </ul>
                        </li>

                    </ul>
                </li>

                <li>
                    <em></em><span>第二级第三个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                    </ul>
                </li>

            </ul>
        </li>
    </ul>
</div>
<script type="text/javascript" src="../utils.js"></script>
<script type="text/javascript">
  var box = document.getElementById('box'),
    spanList = box.getElementsByTagName('span');

  // 第一步：循环容器中所有span标签
  for (var i = 0, len = spanList.length; i < len; i++) {
    var curSpan = spanList[i],
      prevEle = utils.prev(curSpan); // 获取该span标签的哥哥元素
    if (prevEle && prevEle.tagName.toLocaleLowerCase() === 'em') {
      // 如果哥哥元素是em的话，说明这个span下还有ul内容，则设置该span样式cursor = "pointer"
      curSpan.style.cursor = "pointer";
    }
  }

  function handleSpanClick(e) {
    e = e || window.event;
    e.traget = e.target || e.srcElement;

    var tagName = e.target.tagName.toLowerCase(), //获取当前点击元素的tagName
      siblingsUlList = utils.children(e.traget.parentNode, 'ul'), // 获取当前点击元素的兄弟元素中ul元素列表
      prevEle = utils.prev(e.target); // 获取当前事件源的哥哥元素

    // 判断是否真的有兄弟ul元素且点击元素时em或者span
    if (siblingsUlList.length > 0 && (tagName === 'em' || tagName === 'span')) {
      // 确定当前点击操作时显示内容还是隐藏内容
      var isHide = tagName === 'span' ? utils.hasClass(prevEle, 'open') : utils.hasClass(e.target, 'open');
      // 遍历循环每一个兄弟ul元素并操作
      for (var i = 0, len = siblingsUlList.length; i < len; i++) {
        // 这里显示和隐藏都只操作兄弟ul元素！
        //isHide ? siblingsUlList[i].style.display = "none" : siblingsUlList[i].style.display = "block";

        //升级业务逻辑。显示时值操作兄弟ul们显示，但隐藏式不仅把兄弟ul们隐藏，还要把子子孙孙ul们都隐藏
        if (isHide) {
          siblingsUlList[i].style.display = "none";
          var u = siblingsUlList[i].getElementsByTagName('ul'); // 获取这个ul底下的所有ul
          var ems = siblingsUlList[i].getElementsByTagName('em'); // 获取这个ul底下的所有em
          for (var iu=0;iu<u.length;iu++) {
            u[iu].style.display = 'none'; // ul的话就直接应酬
          }
          for (var ie=0;ie<ems.length;ie++) {
            utils.removeClass(ems[ie], 'open'); // em的话就直接删除open样式类名
          }
        } else { // 否者显示
          siblingsUlList[i].style.display = "block";
        }
      }

      // 先判断该元素是否为span，如果是就把它哥哥元素的open样式命名进行toggle
      if (tagName === 'span') {
        utils.toggleClass(prevEle, 'open');
      } else { // 如果不是就说明点的是em元素，就直接把本身样式类名open进行toggle开关
        utils.toggleClass(e.target, 'open');
      }
    }
  }
  // 因为有事件冒泡传播，所以为box绑定点击事件，可以让它的子子孙孙元素点击事件传递给box上~~
  box.addEventListener('click', handleSpanClick, false);
</script>
</body>
</html>
```

- 多级菜单Vanilla.js版实现逻辑总结：
  1. 循环容器中所有span标签，拿到每个标签的哥哥元素，如果哥哥元素是em，则说明这个span下还有ul内容，则设置该span样式cursor = "pointer"；
  2. 创建handleSpanClick函数
  3. 函数里，判断事件源所有有兄弟ul元素且事件源是em或者span元素；【是】先拿到该元素所有兄弟ul元素们，然后循环；
  4. 循环里，先判断em元素是否有open样式，如果有则isHide为true，否者为false；
  5. 接上，如果isHide为true，则先让兄弟ul们隐藏，然后获取在每一个兄弟ul元素的子子孙孙节点中过滤出ul和em，分别循环设置隐藏和删除open样式类名；
  6. 接上，如果isHide为false，就直接让兄弟ul们显示；
  7. 接上，toggle点击的em元素样式类名open，handleSpanClick函数完；
  8. handleSpanClick函数绑定到box的click上

----------

## 课时114：案例之多级菜单jquery版

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson114</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            font-size: 14px;
            -webkit-user-select: none;
            user-select: none;
        }

        ul, li {
            list-style: none;
        }

        .box {
            margin: 10px;
            padding: 10px;
            width: 300px;
            border: 1px dashed #000000;
            /*渐进增强：首先设置一个纯色的背景，对于不兼容CSS3的浏览器的话就用纯色；对于兼容的浏览器的话，我们再下面再额外重复增加一个背景渐变色，这样就会把纯色的背景覆盖。*/
            background: #fede4f; /*PC端兼容css3样式，分别对应webkit、火狐、opera、ie*/
            background: -webkit-linear-gradient(to bottom, red 0%, blue 100%);
            background: -moz-linear-gradient(to bottom, red 0%, blue 100%);
            background: -o-linear-gradient(to bottom, red 0%, blue 100%);
            background: -ms-linear-gradient(to bottom, red 0%, blue 100%);
            background: linear-gradient(to bottom, red 0%, blue 100%);
        }

        .box li {
            position: relative;
            line-height: 30px;
        }

        .box em {
            position: absolute;
            top: 7px;
            left: 0;
            width: 16px;
            height: 16px;
            cursor: pointer;
            background: url("imgs/icon.png") no-repeat -59px -28px;
        }

        .box em.open {
            background-position: -42px -28px;
        }

        .box span {
            display: block;
            padding-left: 20px;
        }

        .box .levelTwo {
            margin-left: 20px;
        }

        .box .levelThree {
            margin-left: 20px;
        }

        .box .levelFour {
            margin-left: 20px;
        }

        .box .levelTwo, .box .levelThree, .box .levelFour {
            display: none;
        }

    </style>
</head>
<body>
<div class="box" id="box">
    <ul>
        <li>
            <em></em><span>第一级第一个</span>
            <ul class="levelTwo">
                <li><span>第二级第一个</span></li>
                <li>
                    <em></em><span>第二级第二个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                        <li>
                            <em></em><span>第三级第三个</span>
                            <ul class="levelFour">
                                <li><span>第四级第一个</span></li>
                                <li><span>第四级第二个</span></li>
                                <li><span>第四级第三个</span></li>
                            </ul>
                        </li>

                    </ul>
                </li>

                <li>
                    <em></em><span>第二级第三个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                    </ul>
                </li>

            </ul>
        </li>
        <li>
            <em></em><span>第一级第一个</span>
            <ul class="levelTwo">
                <li><span>第二级第一个</span></li>
                <li>
                    <em></em><span>第二级第二个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                        <li>
                            <em></em><span>第三级第三个</span>
                            <ul class="levelFour">
                                <li><span>第四级第一个</span></li>
                                <li><span>第四级第二个</span></li>
                                <li><span>第四级第三个</span></li>
                            </ul>
                        </li>

                    </ul>
                </li>

                <li>
                    <em></em><span>第二级第三个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                    </ul>
                </li>

            </ul>
        </li>
    </ul>
</div>
<script type="text/javascript" src="../jquery-1.12.4.js"></script>
<script type="text/javascript">
  var $box = $('#box');
  // 循环em兄弟span加可点击的样式
  $box.find('span').each(function (i, v) {
    var $item = $(v);
    $item.prev().is('em') ? $item.css('cursor', 'pointer') : null;
  });
  
  function handleBoxClick(je) {
    var $target = $(je.currentTarget),
      $siblingsUls = $target.parent().children('ul'),
      tagName = je.target.nodeName.toLowerCase();
    if ($siblingsUls.length > 0 && (tagName === 'span' || tagName === 'em')) {
      var isHide = tagName === 'span' ? $target.parent().hasClass('open') : $target.hasClass('open');
      $siblingsUls.each(function (item) {
        if (isHide) {
          // 隐藏
          $siblingsUls.slideToggle(); //jQuery: -> defaultSpeed:400ms
          $siblingsUls.find('ul').hide(400); // 这里只能隐藏，不能用toggle
          $siblingsUls.find('em').removeClass('open'); // 这里只能删除，不能用toggleClass
        } else {
          // 显示
          $siblingsUls.slideToggle();
        }
        tagName === 'em' ? $target.toggleClass('open') : $target.prev().toggleClass('open');
      })
    }
  }
  // 将点击时间的行为函数委托给box容器下的em和span元素
  $box.delegate('em, span', 'click', handleBoxClick);

</script>
</body>
</html>
```

----------

## 课时115：拖拽demo实现基本的效果

> 鼠标拖拽的原理：
当鼠标在盒子上按下mousedown的时候，我们开始拖拽（给盒子绑定mousemove和mouseup）；
大概盒子移动时，我们开始计算盒子的最新位置；
当鼠标抬起(放松鼠标左键)时，说明拖拽已经结束，我们over和up就没用了，此时我们把这两个事件方法移除。

![lesson115-mouseDrag.png-56.2kB][2]

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson115</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            width: 100%;
        }

        #box {
            position: absolute;
            width: 120px;
            height: 120px;
            top: 100px;
            left: 100px;
            /*一种移动端的居中方法，但容器的margin会被设置得viewport宽度的一半！*/
            /*left:0;*/
            /*right: 0;*/
            /*bottom:0;*/
            /*top:0;*/
            /*margin: auto;*/
            /*另一种居中方法，但也会影响容器margin值！*/
            /*top:50%;*/
            /*left:50%;*/
            /*margin-left: -60px;*/
            /*margin-top: -60px;*/
            background: red;
            cursor: move;
        }
    </style>
</head>
<body>
<div id="box"></div>
<script type="text/javascript">
  var box = document.getElementById('box');

  function down(e) {
    e = e || window.event;
    //坑1: 如果当前left为0时，返回空字符！
    //坑2：要用BOM提供的实时css啊！
    this["prevLeft"] = parseFloat(window.getComputedStyle(this)['left']) || 0;
    this["prevTop"] = parseFloat(window.getComputedStyle(this)['top']) || 0;
    this["prevX"] = parseFloat(e.clientX);
    this["prevY"] = parseFloat(e.clientY);
    // 当鼠标在box按下时，给box绑定mousemove和mouseup事件
    box.addEventListener('mousemove', move, false);
    box.addEventListener('mouseup', up, false);
  }

  function move(e) {
    e = e || window.event;
    var left = this["prevLeft"] + e.clientX - this["prevX"];
    var top = this["prevTop"] + e.clientY - this["prevY"];
    //边界判断
    var minL = 0, minT = 0,
      // 最大盒子的Left值为，当前viewport宽度 - 整个盒子的宽度
      maxL = (document.documentElement.clientWidth || document.body.clientWidth) - this.offsetWidth,
      // 最大盒子的Top值为：当前viewport高度 - 整个盒子的高度
      maxT = (document.documentElement.clientHeight || document.body.clientHeight) - this.offsetHeight;
    // 复杂三元运算符：先判断left小于minL吗，小于就用minL，大于的话(再判断大于maxL吗，大于就用maxL，小于就lefe原值)
    this.style.left = left < minL ? minL : (left > maxL ? maxL : left) + 'px';
    this.style.top = top < minT ? minT : (top > maxT ? maxT : top) + 'px';
  }

  function up(e) {
    e = e || window.event;
    box.removeEventListener('mousemove', move);
    box.removeEventListener('mouseup', up);
  }

  box.addEventListener('mousedown', down, false);
</script>
</body>
</html>
```

----------

## 课时116拖拽demo解决鼠标丢失

- 当鼠标移动过快时，我们的鼠标会脱离盒子，导致盒子的mouseup和mousemove事件都无法移除，这种现象称为“鼠标焦点丢失”。在IE和火狐内核的浏览器中，我们可以使用一个方法把鼠标和盒子绑定在一起即可-->`setCapture()`和`releaseCapture()`。 

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson115</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            width: 100%;
        }

        #box {
            position: absolute;
            width: 120px;
            height: 120px;
            top: 100px;
            left: 100px;
            /*一种移动端的居中方法，但容器的margin会被设置得viewport宽度的一半！*/
            /*left:0;*/
            /*right: 0;*/
            /*bottom:0;*/
            /*top:0;*/
            /*margin: auto;*/
            /*另一种居中方法，但也会影响容器margin值！*/
            /*top:50%;*/
            /*left:50%;*/
            /*margin-left: -60px;*/
            /*margin-top: -60px;*/
            background: red;
            cursor: move;
        }
    </style>
</head>
<body>
<div id="box"></div>
<script type="text/javascript">
  var box = document.getElementById('box');

  function down(e) {
    e = e || window.event;
    //坑1: 如果当前left为0时，返回空字符！
    //坑2：要用BOM提供的实时css啊！
    this["prevLeft"] = parseFloat(window.getComputedStyle(this)['left']) || 0;
    this["prevTop"] = parseFloat(window.getComputedStyle(this)['top']) || 0;
    this["prevX"] = parseFloat(e.clientX);
    this["prevY"] = parseFloat(e.clientY);
    // 为了解决鼠标焦点丢失问题，在IE和FF中我们使用setCapture和releaseCaptrue。而其它浏览器则我们直接将鼠标move和鼠标up事件绑定在document对象上，妥妥的，不丢失！
    // 当鼠标在box按下时，给box绑定mousemove和mouseup事件
    // 如果当前环境兼容setCapture就启动
    if (this.setCapture) {
      this.setCapture();
      this.addEventListener('mousemove', move, false);
      this.addEventListener('mouseup', up, false);
    } else {
      var self = this;
      // 匿名函数参数必须有e，事件会传递进来
      this["MOVE"] = function (e) {
        move.call(self, e);
      };
      this["UP"] = function (e) {
        up.call(self, e);
      };
      document.onmousemove = this["MOVE"];
      document.onmouseup = this["UP"];
    }

  }

  function move(e) {
    e = e || window.event;
    var left = this["prevLeft"] + e.clientX - this["prevX"];
    var top = this["prevTop"] + e.clientY - this["prevY"];
    //边界判断
    var minL = 0, minT = 0,
      // 最大盒子的Left值为，当前viewport宽度 - 整个盒子的宽度
      maxL = (document.documentElement.clientWidth || document.body.clientWidth) - this.offsetWidth,
      // 最大盒子的Top值为：当前viewport高度 - 整个盒子的高度
      maxT = (document.documentElement.clientHeight || document.body.clientHeight) - this.offsetHeight;
    // 复杂三元运算符：先判断left小于minL吗，小于就用minL，大于的话(再判断大于maxL吗，大于就用maxL，小于就lefe原值)
    this.style.left = left < minL ? minL : (left > maxL ? maxL : left) + 'px';
    this.style.top = top < minT ? minT : (top > maxT ? maxT : top) + 'px';
  }

  function up(e) {
    e = e || window.event;
    if (this.releaseCapture) {
      this.releaseCapture();
      this.removeEventListener('mousemove', move);
      this.removeEventListener('mouseup', up);
    } else {
      document.onmousemove = null;
      document.onmouseup = null;
    }

  }

  box.addEventListener('mousedown', down, false);
</script>
</body>
</html>
```


  [1]: http://static.zybuluo.com/szy0syz/l5ie96tnnns94qvvmdoau62u/zf-lesson107.png
  [2]: http://static.zybuluo.com/szy0syz/wli79p74bzsuqvlqm6hgzfkm/lesson115-mouseDrag.png
