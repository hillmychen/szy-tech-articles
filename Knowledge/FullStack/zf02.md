# 珠峰前端全栈培训第二周：call/apply/表格排序/正则

### 课时21：函数的三种角色

![prototype-chain-final](http://ofx24fene.bkt.clouddn.com//img/book/prototype_chain_final.svg)

- Function.prototype是一个匿名函数，操作也和Object.prototype一样。

- 函数本身也会有一些自己的属性：
  - length: 0   形参个数
  - name: "Fn"  函数名称
  - prototype: 类的原型，在原型上定义的方法都是当前Fn这个类实例的共有方法
  - \__proto__: 把函数当做一个普通的对象，指向Function这个类的原型
  
#### 函数是整个JS中最复杂也是最重要的知识点

- 函数存在多面性
  - “普通函数”：它本身就是一个普通函数，执行时会形成私有作用域(闭包)->形参赋值->预解释->代码执行，执行完成后栈内存销毁或不销毁
  - ”类“：它有自己的实例，也有一个叫做`prototype`属性是自己的原型，它的实例都可以执行自己的原型
  - ”普通对象“：和`var obj = {}`中的obj一样，就是一个普通的对象，他作为对象可以有一些自己的私有属性，也可以通过`__proto__`找到`Function.prototype`
  
#### 小例子一枚充分说明函数的三面性

```javascript
var Fn = function () {
  var num = 10
  this.x = 100
}
Fn.prototype.getX = function () { console.log(this.x) }
Fn.aaa = 1000
var f = new Fn
f.num // -> undefined, 因为在构造函数中声明的num仅是私有作用域中的一个变量
f.aaa // -> undefined, aaa是Fn这个对象的私有属性，实例取不到
var res = Fn()   // 使用Fn的堆内存开辟一个私有作用域，里面有num哦🙃
console.log(res) // 函数没返回值，当然也是undefined😎
Fn.aaa
```

----------

### 课时22：call方法深入

```javascript
myAry.slice // -> 让从原型链上找到的slice方法先执行，在执行时，才把myAry数组进行截取等操作
```

#### call方法

```javscript
var obj = { name:"jerryshi.com" }
function fn () { console.log(this) }
fn() // -> 此时this被window对象代替
obj.fn() // -> 报错！
fn.call(obj)
```

- call方法的作用：首先我们让原型上的call方法执行，在执行call方法时，我们让fn方法中的this变为第一个参数值obj，然后再把fn这个函数执行。简单来说，call方法就是改变方法里的this关键字。

#### 简单模拟Function内置的call方法

```javascript
function fn () { console.log(this) }
var obj = { name: "szy" }
Function.prototype.szyCall = function (context) {
  // szyCall方法中的this其实就是当前要操作的和改变其内部this的那个函数
  // 1.让fn中的this关键字变为context的值 -> 某个对象obj
  //   让this这个函数中的“this”关键字变为“context”
  //   然后eval(this.toString().replace('this','context'))
  // 2.让fn方法执行 this()
}
fn.call(obj)
```

#### 面试题

```javascript
function fn1 () { console.log(1) }
function fn2 () { console.log(2) }
fn1.call(fn2) // -> 1 :首先fn1会通过原型链机制找到Function.prototype上的call方法，并且将fn2作为参数传入call方法去执行，此时call方法内的this关键字还是我们要操作的fn1函数。在call方法代码的执行过程中首先让fn1中的this关键字变为fn2，然后fn1的方法执行。
//------------------难度升级----------------------
fn1.call.call(fn2) // -> 首先fn1会通过原型链机制找到Function.prototype上的call方法，然后再让这个call方法再通过原型链找到Function.prototype上的call方法(因为call本身的值也是一个函数，所以同样可以找到Function.prototype)，在第二次找到call方法时让方法执行，此时方法中的this是fn1.call，首先让这个方法(fn1.call)中的this替换为fn2，然后再让fn1.call执行，最终输出2
//------------------举例说明----------------------
function szy (context) {
  // -> 1.让this这个函数中的this关键字替换context
  // -> 2.让this方法执行
  this()
}
Function.prototype.mycall = szy
fn1.mycall.mycall(fn2) 
// -> fn1.mycall -> szy
// szy.mycall(fn2) -> 先让mycall方法执行，mycall中的this是szy，让szy中的this替换为fn2，再让szy执行，会带动szy中的this执行 -> 2

fn1.call.call.call.call(fn2) // -> 2
Function.prototype.call(fn1) // -> undefined, 首先明确最终执行的是Function.prototype，它是一个空函数，执行结果undefined
Function.prototype.call.call.call(fn1) // -> 1
```

> fn1.call(fn2) 这里不管有没fn2这个参数，执行本体还是fn1.
fn1.call.call(fn2) 而这里执行本体已经被替换成了fn2，则最终执行的是fn2。

原理大概这样，首先js引擎在fn1的原型链上找到call方法，但没执行，它发现还有一个call方法，就再通过fn1.call的基础上再去找到call方法，找到第二个call之后，开始执行第二个call方法，此时第二个call方法里的this原先指向fn1.call的地址(是个函数)，但现在是在第二个call里，引擎根据规则会把第二个call里的this指向替换成由形参传入fn2的地址，最后执行fn1.call=fn2被执行。fn2执行时，this是window。

#### 如果call被调用一次时，会将调用主体中的this替换成形参对象；而被调用超过一次时，则调用主体和执行主体会发生转变，最终等于window调用了最后一个call中的形参方法。

