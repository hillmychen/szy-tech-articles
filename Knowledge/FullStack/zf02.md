# 珠峰前端全栈培训第二周：call/apply/表格排序/正则

### 课时21：函数的三种角色

![prototype-chain-final](http://ofx24fene.bkt.clouddn.com//img/book/prototype_chain_final.svg)

- Function.prototype是一个匿名函数，操作也和Object.prototype一样。

- 函数本身也会有一些自己的属性：
  - length: 0   形参个数
  - name: "Fn"  函数名称
  - prototype: 类的原型，在原型上定义的方法都是当前Fn这个类实例的共有方法
  - \__proto__: 把函数当做一个普通的对象，指向Function这个类的原型
  
#### 函数是整个JS中最复杂也是最重要的知识点

- 函数存在多面性
  - “普通函数”：它本身就是一个普通函数，执行时会形成私有作用域(闭包)->形参赋值->预解释->代码执行，执行完成后栈内存销毁或不销毁
  - ”类“：它有自己的实例，也有一个叫做`prototype`属性是自己的原型，它的实例都可以执行自己的原型
  - ”普通对象“：和`var obj = {}`中的obj一样，就是一个普通的对象，他作为对象可以有一些自己的私有属性，也可以通过`__proto__`找到`Function.prototype`
  
#### 小例子一枚充分说明函数的三面性

```javascript
var Fn = function () {
  var num = 10
  this.x = 100
}
Fn.prototype.getX = function () { console.log(this.x) }
Fn.aaa = 1000
var f = new Fn
f.num // -> undefined, 因为在构造函数中声明的num仅是私有作用域中的一个变量
f.aaa // -> undefined, aaa是Fn这个对象的私有属性，实例取不到
var res = Fn()   // 使用Fn的堆内存开辟一个私有作用域，里面有num哦🙃
console.log(res) // 函数没返回值，当然也是undefined😎
Fn.aaa
```

----------

### 课时22：call方法深入

```javascript
myAry.slice // -> 让从原型链上找到的slice方法先执行，在执行时，才把myAry数组进行截取等操作
```

#### call方法

```javscript
var obj = { name:"jerryshi.com" }
function fn () { console.log(this) }
fn() // -> 此时this被window对象代替
obj.fn() // -> 报错！
fn.call(obj)
```

- call方法的作用：首先我们让原型上的call方法执行，在执行call方法时，我们让fn方法中的this变为第一个参数值obj，然后再把fn这个函数执行。简单来说，call方法就是改变方法里的this关键字。

#### 简单模拟Function内置的call方法

```javascript
function fn () { console.log(this) }
var obj = { name: "szy" }
Function.prototype.szyCall = function (context) {
  // szyCall方法中的this其实就是当前要操作的和改变其内部this的那个函数
  // 1.让fn中的this关键字变为context的值 -> 某个对象obj
  //   让this这个函数中的“this”关键字变为“context”
  //   然后eval(this.toString().replace('this','context'))
  // 2.让fn方法执行 this()
}
fn.call(obj)
```

#### 面试题

```javascript
function fn1 () { console.log(1) }
function fn2 () { console.log(2) }
fn1.call(fn2) // -> 1 :首先fn1会通过原型链机制找到Function.prototype上的call方法，并且将fn2作为参数传入call方法去执行，此时call方法内的this关键字还是我们要操作的fn1函数。在call方法代码的执行过程中首先让fn1中的this关键字变为fn2，然后fn1的方法执行。
//------------------难度升级----------------------
fn1.call.call(fn2) // -> 首先fn1会通过原型链机制找到Function.prototype上的call方法，然后再让这个call方法再通过原型链找到Function.prototype上的call方法(因为call本身的值也是一个函数，所以同样可以找到Function.prototype)，在第二次找到call方法时让方法执行，此时方法中的this是fn1.call，首先让这个方法(fn1.call)中的this替换为fn2，然后再让fn1.call执行，最终输出2
//------------------举例说明----------------------
function szy (context) {
  // -> 1.让this这个函数中的this关键字替换context
  // -> 2.让this方法执行
  this()
}
Function.prototype.mycall = szy
fn1.mycall.mycall(fn2) 
// -> fn1.mycall -> szy
// szy.mycall(fn2) -> 先让mycall方法执行，mycall中的this是szy，让szy中的this替换为fn2，再让szy执行，会带动szy中的this执行 -> 2

fn1.call.call.call.call(fn2) // -> 2
Function.prototype.call(fn1) // -> undefined, 首先明确最终执行的是Function.prototype，它是一个空函数，执行结果undefined
Function.prototype.call.call.call(fn1) // -> 1
```

> fn1.call(fn2) 这里不管有没fn2这个参数，执行本体还是fn1.
fn1.call.call(fn2) 而这里执行本体已经被替换成了fn2，则最终执行的是fn2。

原理大概这样，首先js引擎在fn1的原型链上找到call方法，但没执行，它发现还有一个call方法，就再通过fn1.call的基础上再去找到call方法，找到第二个call之后，开始执行第二个call方法，此时第二个call方法里的this原先指向fn1.call的地址(是个函数)，但现在是在第二个call里，引擎根据规则会把第二个call里的this指向替换成由形参传入fn2的地址，最后执行fn1.call=fn2被执行。fn2执行时，this是window。

#### 如果call被调用一次时，会将调用方法主体中的this替换成形参对象来执行；而被调用超过一次时，则调用主体和执行主体会发生转变，最终等于window调用了最后一个call中的形参方法。简单来说call本来就是为了改变某方法中的this来用的。

----------

### 课时23：call、apply和bind的区别

```javascript
var obj = { name: "Jerry Shi" }
function fn (num1, num2) {
  console.log(num1,num2)
  console.log(this)
}
fn(100,200)             // -> this=window, num1=100, num2=200
fn.call(100, 200)       // -> this=100, num1=200, num2=undefined
fn.call(obj, 100, 200)  // -> this=obj, num1=100, num2=200
fn.call()               // -> this=window
fn.call(null)           // -> this=window
fn.call(undefined)      // -> this=window

"use strict" //使用严格模式
fn.call()               // -> this=undefined
fn.call(null)           // -> this=null
fn.call(undefined)      // -> this=undefined
// 在严格模式下，call函数传null时this是this，不传或者传undefined时this是undefined
```

> apply和call方法的作用是一样的，都是用改变方法的this关键字并且执行方法；而且在严格模式下和非严格模式下对于第一个参数是null/undefined这种情况的规律也是一样

```javascript
fn.call(obj, 100, 200)  // call在给fn传递参数时，是一个一个的传递进去(arguments)
fn.apply(obj, [100, 200]) // apply则是把要传给fn的参数统一放在一个数组中传进去
// 但最终两个方法也算把参数逐一传递

// bind：这个放在在IE6~8下不兼容，和call/apply类似也是用来改变this关键字的

fn.call(obj, 1, 2) // -> 改变this和执行fn函数都一起完成了

// 预处理：事先把fn的this改变为我们想要的结果，并把对应的参数也准备好，以后用到就执行，其实就是生成了一个堆内存，没变量接收还不是会被清理
var newFn = fn.bind(obk, 1, 2) // -> 只是把fn中this改为obj，并且给两个形参赋值1和2，但此时并没有把fn这个函数执行，而是替换和赋值好的堆内存地址返回，这个返回值给了newFn这个变量
newFn() // -> 现在才真正执行替换后的堆内存，然后也会生成作用域预解释...
```

----------

### 关于this的知识补充

```javascript
//函数中的this指向和当前函数在哪定义的或者在哪执行的都没有任何的关系
//分析this指向的规律如下:

//[非严格模式]
//1、自执行函数中的this永远是window
//[案例1]
 var obj={
    fn:(function(i){
       //this->window
       return function(){
          //this->obj
       }
    })(0)
 };
 obj.fn();

//2、给元素的某个行为绑定一个方法,当行为触发的时候,执行绑定的方法,此时方法中的this是当前的元素
// [案例1]
 oDiv.onclick=function(){
    //this->oDiv
 };

 // [案例2]
 function fn(){
    //this->window
 }
 oDiv.onclick=function(){
     //this->oDiv
     fn();
 };

//3、方法执行,看方法名前面是否有".",有的话,"."前面是谁this就是谁,没有的话this就是window
// [案例1]
 var obj={fn:fn};
 function fn(){}
 fn.prototype.aa=function(){};
 var f=new fn;

 fn();//this->window
 obj.fn();//this->obj
 fn.prototype.aa();//this->fn.prototype
 f.aa();//this->f
 f.__proto__.aa();//this->f.__proto__->fn.prototype


//4、在构造函数模式中,函数体中的this.xxx=xxx中的this是当前类的一个实例
// [案例1]
 function Fn(){
    this.x=100; //this->f
    this.getX=function(){
        console.log(this);//this->f 因为getX方法执行的时候,"."前面是f,所以this是f
    }
 }
 var f=new Fn;
 f.getX();

//5、使用call/apply来改变this的指向(一但遇到call/apply上述的四条都没用了)


// [严格模式]
"use strict";//->告诉浏览器我们接下来编写的JS代码采用严格模式

//1、自执行函数中的this永远是undefined
// [案例1]
 var obj={
    fn:(function(i){
       //this->undefined
       return function(){
          //this->obj
       }
    })(0)
 };
 obj.fn();

//3、方法执行,看方法名前面是否有".",有的话,"."前面是谁this就是谁,没有的话this就是undefined
// [案例1]
 var obj={fn:fn};
 function fn(){}

 fn();//this->undefined
 obj.fn();//this->obj
```

> 我们发现严格模式下的this相对于非严格模式下的this主要区别在于：对于JS代码中没有写执行主体的情况下,非严格模式下默认都是window执行的,所以this指向的是window;但是在严格的模式下,没有写就是没有执行主体,this指向的是undefined;
***你以为 你以为的 就是你以为的***

----------

### 课时24 获取数组最大值

```javascript
var ary = [44,2,4,9]

// 方法一: 排序法
ary.sort(function (a,b) { return a-b }) // max = ary[ary.length - 1]

// 方法二: 假设法
// 假设当前数组中的第一个就是最大值，然后拿这个值和数组里后面的值逐一比较，如果某一个值比假设值还要大，说明假设错了，我们把假设值进行替换...
// 和自定义属性一样，都是JS中最常见的编程思想
var max = ary[0]
for(var i = 1; i<ary.length; i++) {
  var cur = ary[i]
  cur > max ? max = cur : null
}

// 方法三: Math + apply
Math.max.apply(null, ary)
```
