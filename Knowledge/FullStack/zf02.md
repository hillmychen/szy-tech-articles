# 珠峰前端全栈培训第二周：call/apply/表格排序/正则

### 课时21：函数的三种角色

![prototype-chain-final](http://ofx24fene.bkt.clouddn.com//img/book/prototype_chain_final.svg)

- Function.prototype是一个匿名函数，操作也和Object.prototype一样。

- 函数本身也会有一些自己的属性：
  - length: 0   形参个数
  - name: "Fn"  函数名称
  - prototype: 类的原型，在原型上定义的方法都是当前Fn这个类实例的共有方法
  - \__proto__: 把函数当做一个普通的对象，指向Function这个类的原型
  
#### 函数是整个JS中最复杂也是最重要的知识点

- 函数存在多面性
  - “普通函数”：它本身就是一个普通函数，执行时会形成私有作用域(闭包)->形参赋值->预解释->代码执行，执行完成后栈内存销毁或不销毁
  - ”类“：它有自己的实例，也有一个叫做`prototype`属性是自己的原型，它的实例都可以执行自己的原型
  - ”普通对象“：和`var obj = {}`中的obj一样，就是一个普通的对象，他作为对象可以有一些自己的私有属性，也可以通过`__proto__`找到`Function.prototype`
  
#### 小例子一枚充分说明函数的三面性

```javascript
var Fn = function () {
  var num = 10
  this.x = 100
}
Fn.prototype.getX = function () { console.log(this.x) }
Fn.aaa = 1000
var f = new Fn
f.num // -> undefined, 因为在构造函数中声明的num仅是私有作用域中的一个变量
f.aaa // -> undefined, aaa是Fn这个对象的私有属性，实例取不到
var res = Fn()   // 使用Fn的堆内存开辟一个私有作用域，里面有num哦🙃
console.log(res) // 函数没返回值，当然也是undefined😎
Fn.aaa
```

----------

### 课时22：call方法深入

```javascript
myAry.slice // -> 让从原型链上找到的slice方法先执行，在执行时，才把myAry数组进行截取等操作
```

#### call方法

```javscript
var obj = { name:"jerryshi.com" }
function fn () { console.log(this) }
fn() // -> 此时this被window对象代替
obj.fn() // -> 报错！
fn.call(obj)
```

- call方法的作用：首先我们让原型上的call方法执行，在执行call方法时，我们让fn方法中的this变为第一个参数值obj，然后再把fn这个函数执行。简单来说，call方法就是改变方法里的this关键字。

#### 简单模拟Function内置的call方法

```javascript
function fn () { console.log(this) }
var obj = { name: "szy" }
Function.prototype.szyCall = function (context) {
  // szyCall方法中的this其实就是当前要操作的和改变其内部this的那个函数
  // 1.让fn中的this关键字变为context的值 -> 某个对象obj
  //   让this这个函数中的“this”关键字变为“context”
  //   然后eval(this.toString().replace('this','context'))
  // 2.让fn方法执行 this()
}
fn.call(obj)
```

#### 面试题

```javascript
function fn1 () { console.log(1) }
function fn2 () { console.log(2) }
fn1.call(fn2) // -> 1 :首先fn1会通过原型链机制找到Function.prototype上的call方法，并且将fn2作为参数传入call方法去执行，此时call方法内的this关键字还是我们要操作的fn1函数。在call方法代码的执行过程中首先让fn1中的this关键字变为fn2，然后fn1的方法执行。
//------------------难度升级----------------------
fn1.call.call(fn2) // -> 首先fn1会通过原型链机制找到Function.prototype上的call方法，然后再让这个call方法再通过原型链找到Function.prototype上的call方法(因为call本身的值也是一个函数，所以同样可以找到Function.prototype)，在第二次找到call方法时让方法执行，此时方法中的this是fn1.call，首先让这个方法(fn1.call)中的this替换为fn2，然后再让fn1.call执行，最终输出2
//------------------举例说明----------------------
function szy (context) {
  // -> 1.让this这个函数中的this关键字替换context
  // -> 2.让this方法执行
  this()
}
Function.prototype.mycall = szy
fn1.mycall.mycall(fn2) 
// -> fn1.mycall -> szy
// szy.mycall(fn2) -> 先让mycall方法执行，mycall中的this是szy，让szy中的this替换为fn2，再让szy执行，会带动szy中的this执行 -> 2

fn1.call.call.call.call(fn2) // -> 2
Function.prototype.call(fn1) // -> undefined, 首先明确最终执行的是Function.prototype，它是一个空函数，执行结果undefined
Function.prototype.call.call.call(fn1) // -> 1
```

> fn1.call(fn2) 这里不管有没fn2这个参数，执行本体还是fn1.
fn1.call.call(fn2) 而这里执行本体已经被替换成了fn2，则最终执行的是fn2。

原理大概这样，首先js引擎在fn1的原型链上找到call方法，但没执行，它发现还有一个call方法，就再通过fn1.call的基础上再去找到call方法，找到第二个call之后，开始执行第二个call方法，此时第二个call方法里的this原先指向fn1.call的地址(是个函数)，但现在是在第二个call里，引擎根据规则会把第二个call里的this指向替换成由形参传入fn2的地址，最后执行fn1.call=fn2被执行。fn2执行时，this是window。

#### 如果call被调用一次时，会将调用方法主体中的this替换成形参对象来执行；而被调用超过一次时，则调用主体和执行主体会发生转变，最终等于window调用了最后一个call中的形参方法。简单来说call本来就是为了改变某方法中的this来用的。

----------

### 课时23：call、apply和bind的区别

```javascript
var obj = { name: "Jerry Shi" }
function fn (num1, num2) {
  console.log(num1,num2)
  console.log(this)
}
fn(100,200)             // -> this=window, num1=100, num2=200
fn.call(100, 200)       // -> this=100, num1=200, num2=undefined
fn.call(obj, 100, 200)  // -> this=obj, num1=100, num2=200
fn.call()               // -> this=window
fn.call(null)           // -> this=window
fn.call(undefined)      // -> this=window

"use strict" //使用严格模式
fn.call()               // -> this=undefined
fn.call(null)           // -> this=null
fn.call(undefined)      // -> this=undefined
// 在严格模式下，call函数传null时this是this，不传或者传undefined时this是undefined
```

> apply和call方法的作用是一样的，都是用改变方法的this关键字并且执行方法；而且在严格模式下和非严格模式下对于第一个参数是null/undefined这种情况的规律也是一样

```javascript
fn.call(obj, 100, 200)  // call在给fn传递参数时，是一个一个的传递进去(arguments)
fn.apply(obj, [100, 200]) // apply则是把要传给fn的参数统一放在一个数组中传进去
// 但最终两个方法也算把参数逐一传递

// bind：这个放在在IE6~8下不兼容，和call/apply类似也是用来改变this关键字的

fn.call(obj, 1, 2) // -> 改变this和执行fn函数都一起完成了

// 预处理：事先把fn的this改变为我们想要的结果，并把对应的参数也准备好，以后用到就执行，其实就是生成了一个堆内存，没变量接收还不是会被清理
var newFn = fn.bind(obk, 1, 2) // -> 只是把fn中this改为obj，并且给两个形参赋值1和2，但此时并没有把fn这个函数执行，而是替换和赋值好的堆内存地址返回，这个返回值给了newFn这个变量
newFn() // -> 现在才真正执行替换后的堆内存，然后也会生成作用域预解释...
```

----------

### 关于this的知识补充

```javascript
//函数中的this指向和当前函数在哪定义的或者在哪执行的都没有任何的关系
//分析this指向的规律如下:

//[非严格模式]
//1、自执行函数中的this永远是window
//[案例1]
 var obj={
    fn:(function(i){
       //this->window
       return function(){
          //this->obj
       }
    })(0)
 };
 obj.fn();

//2、给元素的某个行为绑定一个方法,当行为触发的时候,执行绑定的方法,此时方法中的this是当前的元素
// [案例1]
 oDiv.onclick=function(){
    //this->oDiv
 };

 // [案例2]
 function fn(){
    //this->window
 }
 oDiv.onclick=function(){
     //this->oDiv
     fn();
 };

//3、方法执行,看方法名前面是否有".",有的话,"."前面是谁this就是谁,没有的话this就是window
// [案例1]
 var obj={fn:fn};
 function fn(){}
 fn.prototype.aa=function(){};
 var f=new fn;

 fn();//this->window
 obj.fn();//this->obj
 fn.prototype.aa();//this->fn.prototype
 f.aa();//this->f
 f.__proto__.aa();//this->f.__proto__->fn.prototype


//4、在构造函数模式中,函数体中的this.xxx=xxx中的this是当前类的一个实例
// [案例1]
 function Fn(){
    this.x=100; //this->f
    this.getX=function(){
        console.log(this);//this->f 因为getX方法执行的时候,"."前面是f,所以this是f
    }
 }
 var f=new Fn;
 f.getX();

//5、使用call/apply来改变this的指向(一但遇到call/apply上述的四条都没用了)


// [严格模式]
"use strict";//->告诉浏览器我们接下来编写的JS代码采用严格模式

//1、自执行函数中的this永远是undefined
// [案例1]
 var obj={
    fn:(function(i){
       //this->undefined
       return function(){
          //this->obj
       }
    })(0)
 };
 obj.fn();

//3、方法执行,看方法名前面是否有".",有的话,"."前面是谁this就是谁,没有的话this就是undefined
// [案例1]
 var obj={fn:fn};
 function fn(){}

 fn();//this->undefined
 obj.fn();//this->obj
```

> 我们发现严格模式下的this相对于非严格模式下的this主要区别在于：对于JS代码中没有写执行主体的情况下,非严格模式下默认都是window执行的,所以this指向的是window;但是在严格的模式下,没有写就是没有执行主体,this指向的是undefined;
***你以为 你以为的 就是你以为的***

----------

### 课时24 获取数组最大值

```javascript
var ary = [44,2,4,9]

// 方法一: 排序法
ary.sort(function (a,b) { return a-b }) // max = ary[ary.length - 1]

// 方法二: 假设法
// 假设当前数组中的第一个就是最大值，然后拿这个值和数组里后面的值逐一比较，如果某一个值比假设值还要大，说明假设错了，我们把假设值进行替换...
// 和自定义属性一样，都是JS中最常见的编程思想
var max = ary[0]
for(var i = 1; i<ary.length; i++) {
  var cur = ary[i]
  cur > max ? max = cur : null
}

// 方法三: Math + apply
Math.max.apply(null, ary)
```

// 方法四: eval字符串拼接法
max = eval('Math.max(' + ary.toString() +')')

#### 括号表达式

```javascript
function fn1 () { console.log('fn1:' + this) }
function fn2 () { console.log('fn2:' + this) }
var obj = { name: "szy~", fn: fn2 }
//;(fn1,fn2)() // -> fn2:'this'，最后只有fn2执行 -> 在(x1,x2,x3...)括号表达式中，一个括号内出现了多项内容，中间用','隔开，但最后只获得了最后一项
(fn2, obj.fn)() // -> 执行的是obj.fn，但在执行时，作用域里的this变为了window，而不是调用主体obj。这里相当于把这个函数拷贝一份放在那里执行，所以this发生了变化。
(obj.fn)() // -> this=obj调用主体，只有一项时this不发生变化
```

----------

### 课时25：获取平均数

#### 方法一

```javascript
var target = [9.1, 3, 8.8, 10.0, 9.3]
function avgFn () {
  // 创建临时数组
  var ary = []
  // 把函数的参数复制一份到临时数组中
  for (var i = 0; i < arguments.length; i++) {
    ary.push(arguments[i])
  }
  // 从小到大排序
  ary.sort(function (a, b) { return a -b })
  // 去除最小值
  ary.shift()
  // 去除最大值
  ary.pop()
  // 将数组转成x+y+z形式给eval计算
  return (eval(ary.join("+")) / ary.length).toFixed()
}
```

> 构思方法一种用高效处理数据复制，想到了slice~

#### 方法二

```javascript
var target = [9.1, 3, 8.8, 10.0, 9.3]
// 模拟内置的slice发现数组的克隆功能
Array.prototype.mySlice = function () {
  // 此时的 this就是要操作的数组对象！
  //////////////内置方法//////////////
  var tmp = []
  for (var i=0;i<this.length;i++) {
    tmp[tmp.length] = this[i]
  }
  ////////////////////////////////////
  //实现把arguments转换为数组，见方法一！
  // var tmp = []
  // for (var i=0;i < arguments.length;i++) {
  //   tmp[tmp.length] = arguments[i]
  // }
  // 两者区别仅在于上面的this到下面变成了arguments而已，恰恰只改变了this，故我们应该联想到了能够修改方法this的方法。
  return tmp
}

function avgFn () {
  // 其实这里已经不需要转换成数组来处理
  // 将类数组转换为数组：把arguments克隆一份成数组
  // 借用数组原型上的slice方法，当slice执行的时候，让方法中的this变为我们要处理的arguments，实现将类数组转换为数据
  // var ary = Array.prototype.slice.call(arguments)
  // var ary = [].__proto__.slice.call(arguments)
  
  // 同理, 借用数组原型上的排序方法，对arguments类数组进行排序
  Array.prototype.sort.call(arguments, function (a,b) { return a-b })
  // 去除最小值
  [].shift.call(arguments)
  // 去除最大值
  [].shift.pop(arguments)
  // 将数组转成x+y+z形式给eval计算, 全借用原型上的方法
  return (eval([].join.call(arguments,"+")) / arguments.length).toFixed()
}
```

> 从此课时可得，如果我们在类里写了关于this的算法函数，如果可通用的话，可以用call取出来在别的类中继续使用！方法复用性将大大增强！

### 课时26：类数组转换为数组

```javascript
var divs = document.getElementsByTagName("div")
console.dir(divs) // -> HTMLCollections 元素集合类的一个实例(类数组)
divs = document.getElementByName("szy")  
console.dir(divs) // -> NodeList 节点集合类的一个实例(类数组)

var olist = document.getElementsByTagName('div')
var ary = Array.prototype.slice.call(olist)
// -> 在IE6~8中，不支持借用数组的slice实现将元素集合(节点集合)的类数组转换为数组 -> Array.prototype.slice: 'this' 不是 JavaScript 对象！
// -> 但对于arguments借用数组的方法时没有兼容性问题，如果要兼容写循环数组push元素
```

> 作业：查找JS中所有获取元素的方法，查看他们返回的类型。

#### 浏览器的异常信息捕获

> try catch finlly

```javascript
// 实现将类数组转换为数组
function listToArray (likeArr) {
  var arr = []
  try {
    arr = [].__proto__.slice.call(likeArr)
  } catch (e) {
    for (var i=0; i < likeArr.length; i++) {
      arr[arr.length] = likeArr[i]  
    }
  }
  return arr
}
```

### 课时27：sort方法深入研究

#### 回调函数：把一个方法A当做参数值传递给另外一个函数B，然后在B执行的过程中，我们随时根据需求让A方法执行

```javascript
//sort方法会调用length-1次回调函数

//扩张
var ary = [{name:"小飞"}, {name:"小李"}, {name:"小王"}]
ary.sort(function (a,b) {return a.name.localCompare(b.name)})
//使用字符串进行排序，localCompare会将汉字先转换成拼音比较，如果还比不出来再转Unicode代码比较
```

### 课时28：json及操作

- JSON不是一个单独的数据类型，它只是一种特殊的数据格式 -> 它是对象数据类型。JSON格式的对象（相较于普通格式来说，仅是把属性名用双引号抱起来而已）

- 在window浏览器对象中，提供了一个叫JSON的属性，它里面提供了两个方法:
  - JSON.parse:：把JSON格式的字符串转换为JSON格式的对象
  - JSON.stringify：把JSON格式的对象转换为JSON格式的字符串

> 作业：写兼容全浏览器的JSON.parse和JSON.stringify

### 课时29：数据绑定及dom回流

```jajvascript
// 方法一：动态状态元素法
// 优势：
// 劣势：每次动态创建一个li，我们就添加到页面当中，引发一起DOM回流，最后引发回流次数过多，影响性能！

// 方法二：字符串拼接法

// 优势：事先把内容拼接好，最后统一添加到页面中，只引发一次回流
// 劣势：我们把新拼接的字符串添加到#ul1中，原有那三个li的鼠标划过效果消失了(原来绑定的DOM事件全部消失)

// 方法三：文档碎片
var frg = document.createDocumentFragment()  // -> 创建一个文档碎片，相当于临时创建了一个容器
for (var i = 0; i < ary.length; i++) {
  var cur = ary[i]
  var oli = document.createElement("li")
  oli.innerHTML = "<span>" + (i + 4) + "</span>" + cur.titel
  frg.appendChild(oli)
}
oul.appendChild(frg)
frg = null // -> 手动释放frg的堆内存
```

#### JS中DOM深入知识：
- 回流(重排 reflow)：当页面中的HTML结构发生改变（增加、删除元素、位置发生改变 ...），浏览器都需要从新计算一遍最新的DOM结构，从新的对当前页面进行渲染

- 重绘：某一个元素的部分样式发生改变了，浏览器只需要重新渲染当前元素即可

> JS优化小细节：严禁DOM回流

### 课时30：表格排序及dom映射

```html
<ul id="ul1">
    <li>98</li>
    <li>99</li>
    <li>96</li>
    <li>90</li>
    <li>95</li>
</ul>
```

```javascript
// 类数组转换成数组
function listToArray (likeArr) {
  var arr = []
  try {
    arr = [].__proto__.slice.call(likeArr)
  } catch (e) {
    for (var i=0; i < likeArr.length; i++) {
      arr[arr.length] = likeArr[i]  
    }
  }
  return arr
}

// 表格排序
// 1.取得要排序的类数组li
var oUl = document.getElementById("ul1")
var oLis = oUl.getElementByTagName("li")
// 2.先把元素集合类数组转换为数组
var ary = listToArray(oLis)
// 3.给转换后的数组进行排序
ary.sort(function (a,b) {
  return parseFloat(a.innerHTML) - parseFloat(b.innerHTML) // 其实这里找子节点拿nodeValue更专业些！
})
// 4. 按照ary中存储的最新顺序使用文档碎片依次的把对应的li添加到页面中
var frg = document.createDocumentFragment()
for (var i=0; i<ary.length; i++) {
  frg.appendChild(ary[i])
}
oUl.appendChild(frg) // 体现DOM映射机制
frg = null
```

#### DOM映射机制：页面中的标签和JS中获取到的元素对象(元素集合)是紧紧绑定在一起的，页面中的HTML结构变了，JS中不需要重新获取，集合中的内容也会跟着自动改变

```javascript
// 举例说明
var oUl = document.getElementById("ul1")
var oLis = oUl.getElementByTagName("li")
console.log(oLis.length) // -> 5
var tli = document.createElement("li")
oUl.appendChild(tli)
console.log(oLis.length) // -> 6
```

![dom-mapping](http://ofx24fene.bkt.clouddn.com//img/blog/DOM-mapping.svg)
